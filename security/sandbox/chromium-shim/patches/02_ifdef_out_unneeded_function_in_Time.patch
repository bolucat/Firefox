# User Bob Owen <bobowencode@gmail.com>
Don't compile (or remove) the following from class Time: FromStringInternal,
Midnight, UTCExplode, LocalExplode, UTCMidnight, LocalMidnight and operator<<.

The first has a dependency on nspr, which causes issues. The others are not
needed and bring in more dependencies.

Also remove base::subtle::LiveTicksNowIgnoringOverride and calling functions as
they create a dependency on mincore lib and are not used.

diff --git a/base/time/time.cc b/base/time/time.cc
--- a/base/time/time.cc
+++ b/base/time/time.cc
@@ -33,18 +33,20 @@ std::atomic<TimeNowFunction> g_time_now_
     &subtle::TimeNowIgnoringOverride};
 
 std::atomic<TimeNowFunction> g_time_now_from_system_time_function{
     &subtle::TimeNowFromSystemTimeIgnoringOverride};
 
 std::atomic<TimeTicksNowFunction> g_time_ticks_now_function{
     &subtle::TimeTicksNowIgnoringOverride};
 
+#if !defined(MOZ_SANDBOX)
 std::atomic<LiveTicksNowFunction> g_live_ticks_now_function{
     &subtle::LiveTicksNowIgnoringOverride};
+#endif
 
 std::atomic<ThreadTicksNowFunction> g_thread_ticks_now_function{
     &subtle::ThreadTicksNowIgnoringOverride};
 
 }  // namespace internal
 
 // TimeDelta ------------------------------------------------------------------
 
@@ -92,16 +94,17 @@ Time Time::Now() {
 
 // static
 Time Time::NowFromSystemTime() {
   // Just use g_time_now_function because it returns the system time.
   return internal::g_time_now_from_system_time_function.load(
       std::memory_order_relaxed)();
 }
 
+#if !defined(MOZ_SANDBOX)
 Time Time::Midnight(bool is_local) const {
   Exploded exploded;
   Explode(is_local, &exploded);
   exploded.hour = 0;
   exploded.minute = 0;
   exploded.second = 0;
   exploded.millisecond = 0;
   Time out_time;
@@ -142,16 +145,17 @@ bool Time::FromStringInternal(const char
                                        is_local ? PR_FALSE : PR_TRUE,
                                        &result_time);
   if (result != PR_SUCCESS)
     return false;
 
   *parsed_time = UnixEpoch() + Microseconds(result_time);
   return true;
 }
+#endif
 
 // static
 bool Time::ExplodedMostlyEquals(const Exploded& lhs, const Exploded& rhs) {
   return std::tie(lhs.year, lhs.month, lhs.day_of_month, lhs.hour, lhs.minute,
                   lhs.second, lhs.millisecond) ==
          std::tie(rhs.year, rhs.month, rhs.day_of_month, rhs.hour, rhs.minute,
                   rhs.second, rhs.millisecond);
 }
@@ -182,32 +186,34 @@ int64_t Time::ToRoundedDownMillisecondsS
   // If |us_| is negative and includes fractions of a millisecond, subtract one
   // more to effect the round towards -infinity. C-style integer truncation
   // takes care of all other cases.
   const int64_t millis = us_ / kMicrosecondsPerMillisecond;
   const int64_t submillis = us_ % kMicrosecondsPerMillisecond;
   return millis - kEpochOffsetMillis - (submillis < 0);
 }
 
+#if !defined(MOZ_SANDBOX)
 std::ostream& operator<<(std::ostream& os, Time time) {
   Time::Exploded exploded;
   time.UTCExplode(&exploded);
   // Can't call `UnlocalizedTimeFormatWithPattern()`/`TimeFormatAsIso8601()`
   // since `//base` can't depend on `//base:i18n`.
   //
   // TODO(pkasting): Consider whether `operator<<()` should move to
   // `base/i18n/time_formatting.h` -- would let us implement in terms of
   // existing time formatting, but might be confusing.
   return os << StringPrintf("%04d-%02d-%02d %02d:%02d:%02d.%06" PRId64 " UTC",
                             exploded.year, exploded.month,
                             exploded.day_of_month, exploded.hour,
                             exploded.minute, exploded.second,
                             time.ToDeltaSinceWindowsEpoch().InMicroseconds() %
                                 Time::kMicrosecondsPerSecond);
 }
+#endif
 
 // TimeTicks ------------------------------------------------------------------
 
 // static
 TimeTicks TimeTicks::Now() {
   return internal::g_time_ticks_now_function.load(std::memory_order_relaxed)();
 }
 
@@ -262,20 +268,22 @@ std::ostream& operator<<(std::ostream& o
   // real microseconds, the only real guarantee is that the number never goes
   // down during a single run.
   const TimeDelta as_time_delta = time_ticks - TimeTicks();
   return os << as_time_delta.InMicroseconds() << " bogo-microseconds";
 }
 
 // LiveTicks ------------------------------------------------------------------
 
+#if !defined(MOZ_SANDBOX)
 // static
 LiveTicks LiveTicks::Now() {
   return internal::g_live_ticks_now_function.load(std::memory_order_relaxed)();
 }
+#endif
 
 #if !BUILDFLAG(IS_WIN)
 namespace subtle {
 LiveTicks LiveTicksNowIgnoringOverride() {
   // On non-windows platforms LiveTicks is equivalent to TimeTicks already.
   // Subtract the empty `TimeTicks` from `TimeTicks::Now()` to get a `TimeDelta`
   // that can be added to the empty `LiveTicks`.
   return LiveTicks() + (TimeTicks::Now() - TimeTicks());
diff --git a/base/time/time.h b/base/time/time.h
--- a/base/time/time.h
+++ b/base/time/time.h
@@ -804,16 +804,17 @@ class BASE_EXPORT Time : public time_int
                                        Time* parsed_time) {
     return FromStringInternal(time_string, true, parsed_time);
   }
   [[nodiscard]] static bool FromUTCString(const char* time_string,
                                           Time* parsed_time) {
     return FromStringInternal(time_string, false, parsed_time);
   }
 
+#if !defined(MOZ_SANDBOX)
   // Fills the given |exploded| structure with either the local time or UTC from
   // this Time instance. If the conversion cannot be made, the output will be
   // assigned invalid values. Use Exploded::HasValidValues() to confirm a
   // successful conversion.
   //
   // Y10K compliance: This method will successfully convert all Times that
   // represent dates on/after the start of the year 1601 and on/before the start
   // of the year 30828. Some platforms might convert over a wider input range.
@@ -822,16 +823,17 @@ class BASE_EXPORT Time : public time_int
   // on Exploded for more information.
   void UTCExplode(Exploded* exploded) const { Explode(false, exploded); }
   void LocalExplode(Exploded* exploded) const { Explode(true, exploded); }
 
   // The following two functions round down the time to the nearest day in
   // either UTC or local time. It will represent midnight on that day.
   Time UTCMidnight() const { return Midnight(false); }
   Time LocalMidnight() const { return Midnight(true); }
+#endif
 
   // For legacy deserialization only. Converts an integer value representing
   // Time to a class. This may be used when deserializing a |Time| structure,
   // using a value known to be compatible. It is not provided as a constructor
   // because the integer type may be unclear from the perspective of a caller.
   //
   // DEPRECATED - Do not use in new code. When deserializing from `base::Value`,
   // prefer the helpers from //base/json/values_util.h instead.
diff --git a/base/time/time_win.cc b/base/time/time_win.cc
--- a/base/time/time_win.cc
+++ b/base/time/time_win.cc
@@ -639,25 +639,27 @@ bool TimeTicks::IsConsistentAcrossProces
 // static
 TimeTicks::Clock TimeTicks::GetClock() {
   return IsHighResolution() ? Clock::WIN_QPC
                             : Clock::WIN_ROLLOVER_PROTECTED_TIME_GET_TIME;
 }
 
 // LiveTicks ------------------------------------------------------------------
 
+#if !defined(MOZ_SANDBOX)
 namespace subtle {
 LiveTicks LiveTicksNowIgnoringOverride() {
   ULONGLONG unbiased_interrupt_time;
   QueryUnbiasedInterruptTimePrecise(&unbiased_interrupt_time);
   // QueryUnbiasedInterruptTimePrecise gets the interrupt time in system time
   // units of 100 nanoseconds.
   return LiveTicks() + Nanoseconds(unbiased_interrupt_time * 100);
 }
 }  // namespace subtle
+#endif
 
 // ThreadTicks ----------------------------------------------------------------
 
 namespace subtle {
 ThreadTicks ThreadTicksNowIgnoringOverride() {
   return ThreadTicks::GetForThread(PlatformThread::CurrentHandle());
 }
 }  // namespace subtle
