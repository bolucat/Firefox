# HG changeset patch
# User Bob Owen <bobowencode@gmail.com>
# Date 1733481845 0
#      Fri Dec 06 10:44:05 2024 +0000
# Node ID 05db427a0e8bc9c49ffb2ee7825d150a2c07947c
# Parent  43d313539f5fb692952b8c6eee9fa8d9b7e48fce
Bug 1935962: When ks3rdhmpg.dll is loaded in the parent, allow Everyone SID for USER_RESTRICTED. r=yjuglaret!

The crash caused by ks3rdhmpg.dll under USER_RESTRICTED appears to be down to
the KnownDlls directory being blocked. Not setting the Everyone SID to deny only
will allow access. It will also allow access to other resources that allow the
Everyone and Restricted SIDs, but this will still be an improvement over
USER_LIMITED.

diff --git a/sandbox/win/src/restricted_token_utils.cc b/sandbox/win/src/restricted_token_utils.cc
--- a/sandbox/win/src/restricted_token_utils.cc
+++ b/sandbox/win/src/restricted_token_utils.cc
@@ -30,17 +30,18 @@ DWORD GetObjectSecurityDescriptor(HANDLE
 }  // namespace
 
 absl::optional<base::win::AccessToken> CreateRestrictedToken(
     TokenLevel security_level,
     IntegrityLevel integrity_level,
     TokenType token_type,
     bool lockdown_default_dacl,
     const absl::optional<base::win::Sid>& unique_restricted_sid,
-    bool use_restricting_sids) {
+    bool use_restricting_sids,
+    bool allow_everyone_for_user_restricted) {
   RestrictedToken restricted_token;
   if (lockdown_default_dacl) {
     restricted_token.SetLockdownDefaultDacl();
   }
   if (unique_restricted_sid) {
     restricted_token.AddDefaultDaclSid(*unique_restricted_sid,
                                        base::win::SecurityAccessMode::kGrant,
                                        GENERIC_ALL);
@@ -130,16 +131,19 @@ absl::optional<base::win::AccessToken> C
         restricted_token.AddRestrictingSidLogonSession();
       } else {
         restricted_token.AddUserSidForDenyOnly();
       }
       break;
     case USER_RESTRICTED:
       if (use_restricting_sids) {
         restricted_token.AddRestrictingSid(base::win::WellKnownSid::kRestricted);
+        if (allow_everyone_for_user_restricted) {
+          AddSidException(sid_exceptions, base::win::WellKnownSid::kWorld);
+        }
         if (unique_restricted_sid) {
           restricted_token.AddRestrictingSid(*unique_restricted_sid);
         }
       } else {
         restricted_token.AddUserSidForDenyOnly();
       }
       break;
     case USER_LOCKDOWN:
diff --git a/sandbox/win/src/restricted_token_utils.h b/sandbox/win/src/restricted_token_utils.h
--- a/sandbox/win/src/restricted_token_utils.h
+++ b/sandbox/win/src/restricted_token_utils.h
@@ -35,17 +35,18 @@ enum class TokenType { kImpersonation, k
 // If the function succeeds, the return value is the restricted token. If it
 // fails then the return value is empty.
 absl::optional<base::win::AccessToken> CreateRestrictedToken(
     TokenLevel security_level,
     IntegrityLevel integrity_level,
     TokenType token_type,
     bool lockdown_default_dacl,
     const absl::optional<base::win::Sid>& unique_restricted_sid,
-    bool use_restricting_sids);
+    bool use_restricting_sids,
+    bool allow_everyone_for_user_restricted);
 
 // Hardens the integrity level policy on a token. Specifically it sets the
 // policy to block read and execute so that a lower privileged process cannot
 // open the token for impersonate or duplicate permissions. This should limit
 // potential security holes.
 // `token` must be a token with READ_CONTROL and WRITE_OWNER access.
 // If the function succeeds, the return value is ERROR_SUCCESS. If the
 // function fails, the return value is the win32 error code corresponding to
diff --git a/sandbox/win/src/sandbox_policy.h b/sandbox/win/src/sandbox_policy.h
--- a/sandbox/win/src/sandbox_policy.h
+++ b/sandbox/win/src/sandbox_policy.h
@@ -86,16 +86,22 @@ class [[clang::lto_visibility_public]] T
   // Sets that we should not use restricting SIDs in the access tokens. We need
   // to do this in some circumstances even though it weakens the sandbox.
   // The default is to use them.
   virtual void SetDoNotUseRestrictingSIDs() = 0;
 
   // Returns whether we are using restricting SIDs.
   virtual bool GetUseRestrictingSIDs() = 0;
 
+  // When called the Everyone SID won't be set to deny only for USER_RESTRICED.
+  virtual void SetAllowEveryoneForUserRestricted() = 0;
+
+  // Returns whether the Everyone SID won't be deny only for USER_RESTRICED.
+  virtual bool GetAllowEveryoneForUserRestricted() = 0;
+
   // Sets the security level of the Job Object to which the target process will
   // belong. This setting is permanent and cannot be changed once the target
   // process is spawned. The job controls the global security settings which
   // can not be specified in the token security profile.
   // job_level: the security level for the job. See the explanation of each
   //   level in the JobLevel definition.
   // ui_exceptions: specify what specific rights that are disabled in the
   //   chosen job_level that need to be granted. Use this parameter to avoid
diff --git a/sandbox/win/src/sandbox_policy_base.cc b/sandbox/win/src/sandbox_policy_base.cc
--- a/sandbox/win/src/sandbox_policy_base.cc
+++ b/sandbox/win/src/sandbox_policy_base.cc
@@ -424,16 +424,24 @@ TokenLevel ConfigBase::GetLockdownTokenL
 void ConfigBase::SetDoNotUseRestrictingSIDs() {
   use_restricting_sids_ = false;
 }
 
 bool ConfigBase::GetUseRestrictingSIDs() {
   return use_restricting_sids_;
 }
 
+void ConfigBase::SetAllowEveryoneForUserRestricted() {
+  allow_everyone_for_user_restricted_ = true;
+}
+
+bool ConfigBase::GetAllowEveryoneForUserRestricted() {
+  return allow_everyone_for_user_restricted_;
+}
+
 ResultCode ConfigBase::SetJobLevel(JobLevel job_level, uint32_t ui_exceptions) {
   job_level_ = job_level;
   ui_exceptions_ = ui_exceptions;
   return SBOX_ALL_OK;
 }
 
 JobLevel ConfigBase::GetJobLevel() const {
   return job_level_;
@@ -600,17 +608,18 @@ ResultCode PolicyBase::MakeTokens(
   }
 
   IntegrityLevel integrity_level = config()->integrity_level();
   bool lockdown_default_dacl = config()->lockdown_default_dacl();
   // Create the 'naked' token. This will be the permanent token associated
   // with the process and therefore with any thread that is not impersonating.
   absl::optional<base::win::AccessToken> primary = CreateRestrictedToken(
       config()->GetLockdownTokenLevel(), integrity_level, TokenType::kPrimary,
-      lockdown_default_dacl, random_sid, config()->GetUseRestrictingSIDs());
+      lockdown_default_dacl, random_sid, config()->GetUseRestrictingSIDs(),
+      config()->GetAllowEveryoneForUserRestricted());
   if (!primary) {
     return SBOX_ERROR_CANNOT_CREATE_RESTRICTED_TOKEN;
   }
 
   AppContainerBase* app_container = config()->app_container();
   if (app_container &&
       app_container->GetAppContainerType() == AppContainerType::kLowbox) {
     // Build the lowbox lockdown (primary) token.
@@ -628,17 +637,18 @@ ResultCode PolicyBase::MakeTokens(
   lockdown = std::move(*primary);
 
   // Create the 'better' token. We use this token as the one that the main
   // thread uses when booting up the process. It should contain most of
   // what we need (before reaching main( ))
   absl::optional<base::win::AccessToken> impersonation = CreateRestrictedToken(
       config()->GetInitialTokenLevel(), integrity_level,
       TokenType::kImpersonation, lockdown_default_dacl, random_sid,
-      config()->GetUseRestrictingSIDs());
+      config()->GetUseRestrictingSIDs(),
+      config()->GetAllowEveryoneForUserRestricted());
   if (!impersonation) {
     return SBOX_ERROR_CANNOT_CREATE_RESTRICTED_IMP_TOKEN;
   }
 
   if (app_container) {
     impersonation = app_container->BuildImpersonationToken(*impersonation);
     if (!impersonation) {
       return SBOX_ERROR_CANNOT_CREATE_LOWBOX_IMPERSONATION_TOKEN;
diff --git a/sandbox/win/src/sandbox_policy_base.h b/sandbox/win/src/sandbox_policy_base.h
--- a/sandbox/win/src/sandbox_policy_base.h
+++ b/sandbox/win/src/sandbox_policy_base.h
@@ -55,16 +55,18 @@ class ConfigBase final : public TargetPo
 
   bool IsConfigured() const override;
 
   ResultCode SetTokenLevel(TokenLevel initial, TokenLevel lockdown) override;
   TokenLevel GetInitialTokenLevel() const override;
   TokenLevel GetLockdownTokenLevel() const override;
   void SetDoNotUseRestrictingSIDs() final;
   bool GetUseRestrictingSIDs() final;
+  void SetAllowEveryoneForUserRestricted() final;
+  bool GetAllowEveryoneForUserRestricted() final;
   ResultCode SetJobLevel(JobLevel job_level, uint32_t ui_exceptions) override;
   JobLevel GetJobLevel() const override;
   void SetJobMemoryLimit(size_t memory_limit) override;
   ResultCode AllowFileAccess(FileSemantics semantics,
                              const wchar_t* pattern) override;
   ResultCode AllowNamedPipes(const wchar_t* pattern) override;
   ResultCode AllowExtraDlls(const wchar_t* pattern) override;
   ResultCode SetFakeGdiInit() override;
@@ -134,16 +136,17 @@ class ConfigBase final : public TargetCo
   Desktop desktop() { return desktop_; }
   // nullptr if no objects have been added via AddKernelObjectToClose().
   HandleCloser* handle_closer() { return handle_closer_.get(); }
   bool zero_appshim() { return zero_appshim_; }
 
   TokenLevel lockdown_level_;
   TokenLevel initial_level_;
   bool use_restricting_sids_ = true;
+  bool allow_everyone_for_user_restricted_ = false;
   JobLevel job_level_;
   IntegrityLevel integrity_level_;
   IntegrityLevel delayed_integrity_level_;
   MitigationFlags mitigations_;
   MitigationFlags delayed_mitigations_;
   bool add_restricting_random_sid_;
   bool lockdown_default_dacl_;
   bool is_csrss_connected_;
