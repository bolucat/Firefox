# HG changeset patch
# User Bob Owen <bobowencode@gmail.com>
# Date 1632737723 -3600
#      Mon Sep 27 11:15:23 2021 +0100
# Node ID 096696bc1648dbacdfab881c4ed8fe770ebe58b1
# Parent  254b1fc8768f67d208af199135276abae9aabc0c
Bug 1713973 p2: Add Uniscribe Line Breaking via chromium-sandbox IPC. r=toshi!,r=jfkthame!

This adds a new cross call using the chromium shared memory IPC to proxy use of
the Uniscribe line breaker, because it cannot be used in the content process
with win32k lockdown enabled.

If the text being processed is too long to fit into the IPC params then it is
processed in chunks.

This change implements an INPTR_TYPE in the sandbox, which appears to have
been removed at some point.
It also fixes a bug in OpcodeFactory::MakeOpAction, so that a null param is
passed and we can use an empty parameter set.

New files are in chromium-shim as these are most likely to require changes and
this means we will not have to update the main chromium patch.

diff --git a/sandbox/win/src/crosscall_client.h b/sandbox/win/src/crosscall_client.h
--- a/sandbox/win/src/crosscall_client.h
+++ b/sandbox/win/src/crosscall_client.h
@@ -39,20 +39,16 @@
 //             interpretation of the answer is private to client and server.
 //
 // The return value is ALL_OK if the IPC was delivered to the server, other
 // return codes indicate that the IPC transport failed to deliver it.
 namespace sandbox {
 
 enum class IpcTag;
 
-// this is the assumed channel size. This can be overridden in a given
-// IPC implementation.
-const uint32_t kIPCChannelSize = 1024;
-
 // The copy helper uses templates to deduce the appropriate copy function to
 // copy the input parameters in the buffer that is going to be send across the
 // IPC. These template facility can be made more sophisticated as need arises.
 
 // The default copy helper. It catches the general case where no other
 // specialized template matches better. We set the type to UINT32_TYPE, so this
 // only works with objects whose size is 32 bits.
 template <typename T>
@@ -207,16 +203,42 @@ class CopyHelper<const wchar_t[n]> : pub
 // parameters.
 class InOutCountedBuffer : public CountedBuffer {
  public:
   InOutCountedBuffer(void* buffer, uint32_t size)
       : CountedBuffer(buffer, size) {}
 };
 
 // This copy helper template specialization catches the cases where the
+// parameter is a an input buffer.
+template <>
+class CopyHelper<CountedBuffer> {
+ public:
+  CopyHelper(const CountedBuffer t) : t_(t) {}
+
+  // Returns the pointer to the start of the string.
+  const void* GetStart() const { return t_.Buffer(); }
+
+  // Update not required so just return true;
+  bool Update(void* buffer) { return true; }
+
+  // Returns the size of the string in bytes. We define a nullptr string to
+  // be of zero length.
+  uint32_t GetSize() const { return t_.Size(); }
+
+  // Returns true if the current type is used as an In or InOut parameter.
+  bool IsInOut() { return false; }
+
+  ArgType GetType() { return INPTR_TYPE; }
+
+ private:
+  const CountedBuffer t_;
+};
+
+// This copy helper template specialization catches the cases where the
 // parameter is a an input/output buffer.
 template <>
 class CopyHelper<InOutCountedBuffer> {
  public:
   explicit CopyHelper(const InOutCountedBuffer t) : t_(t) {}
 
   // Returns the pointer to the start of the string.
   const void* GetStart() const { return t_.Buffer(); }
diff --git a/sandbox/win/src/crosscall_params.h b/sandbox/win/src/crosscall_params.h
--- a/sandbox/win/src/crosscall_params.h
+++ b/sandbox/win/src/crosscall_params.h
@@ -41,16 +41,20 @@
 // them are not supported.
 //
 // Another limitation of CrossCall is that the return value and output
 // parameters can only be uint32_t integers. Returning complex structures or
 // strings is not supported.
 
 namespace sandbox {
 
+// this is the assumed channel size. This can be overridden in a given
+// IPC implementation.
+const uint32_t kIPCChannelSize = 1024;
+
 // This is the list of all imported symbols from ntdll.dll.
 SANDBOX_INTERCEPT NtExports g_nt;
 
 namespace {
 
 // Increases |value| until there is no need for padding given an int64_t
 // alignment. Returns the increased value.
 inline uint32_t Align(uint32_t value) {
@@ -216,16 +220,21 @@ class ActualCallParams : public CrossCal
       : CrossCallParams(tag, number_params) {
     param_info_[0].offset_ =
         static_cast<uint32_t>(parameters_ - reinterpret_cast<char*>(this));
   }
 
   ActualCallParams(const ActualCallParams&) = delete;
   ActualCallParams& operator=(const ActualCallParams&) = delete;
 
+  static constexpr size_t MaxParamsSize() {
+    return sizeof(
+        ActualCallParams<NUMBER_PARAMS, kIPCChannelSize>::parameters_);
+  }
+
   // Testing-only method. Allows setting the apparent size to a wrong value.
   // returns the previous size.
   uint32_t OverrideSize(uint32_t new_size) {
     uint32_t previous_size = param_info_[NUMBER_PARAMS].offset_;
     param_info_[NUMBER_PARAMS].offset_ = new_size;
     return previous_size;
   }
 
diff --git a/sandbox/win/src/crosscall_server.cc b/sandbox/win/src/crosscall_server.cc
--- a/sandbox/win/src/crosscall_server.cc
+++ b/sandbox/win/src/crosscall_server.cc
@@ -301,17 +301,17 @@ bool CrossCallParamsEx::GetParameterStr(
 
 bool CrossCallParamsEx::GetParameterPtr(uint32_t index,
                                         uint32_t expected_size,
                                         void** pointer) {
   uint32_t size = 0;
   ArgType type;
   void* start = GetRawParameter(index, &size, &type);
 
-  if ((size != expected_size) || (INOUTPTR_TYPE != type))
+  if ((size != expected_size) || (INOUTPTR_TYPE != type && INPTR_TYPE != type))
     return false;
 
   if (!start)
     return false;
 
   *pointer = start;
   return true;
 }
diff --git a/sandbox/win/src/ipc_args.cc b/sandbox/win/src/ipc_args.cc
--- a/sandbox/win/src/ipc_args.cc
+++ b/sandbox/win/src/ipc_args.cc
@@ -15,16 +15,17 @@ namespace sandbox {
 void ReleaseArgs(const IPCParams* ipc_params, void* args[kMaxIpcParams]) {
   for (size_t i = 0; i < kMaxIpcParams; i++) {
     switch (ipc_params->args[i]) {
       case WCHAR_TYPE: {
         delete reinterpret_cast<std::wstring*>(args[i]);
         args[i] = nullptr;
         break;
       }
+      case INPTR_TYPE:
       case INOUTPTR_TYPE: {
         delete reinterpret_cast<CountedBuffer*>(args[i]);
         args[i] = nullptr;
         break;
       }
       default:
         break;
     }
@@ -69,16 +70,17 @@ bool GetArgs(CrossCallParamsEx* params,
           void* data;
           if (!params->GetParameterVoidPtr(i, &data)) {
             ReleaseArgs(ipc_params, args);
             return false;
           }
           args[i] = data;
           break;
         }
+        case INPTR_TYPE:
         case INOUTPTR_TYPE: {
           if (!args[i]) {
             ReleaseArgs(ipc_params, args);
             return false;
           }
           CountedBuffer* buffer = new CountedBuffer(args[i], size);
           args[i] = buffer;
           break;
diff --git a/sandbox/win/src/ipc_tags.h b/sandbox/win/src/ipc_tags.h
--- a/sandbox/win/src/ipc_tags.h
+++ b/sandbox/win/src/ipc_tags.h
@@ -41,16 +41,17 @@ enum class IpcTag {
   NTQUERYFULLATTRIBUTESFILE,
   NTSETINFO_RENAME,
   NTOPENTHREAD,
   NTOPENPROCESSTOKENEX,
   GDI_GDIDLLINITIALIZE,
   GDI_GETSTOCKOBJECT,
   USER_REGISTERCLASSW,
   CREATETHREAD,
+  GETCOMPLEXLINEBREAKS,
   NTCREATESECTION,
   LAST
 };
 
 constexpr size_t kMaxServiceCount = 64;
 constexpr size_t kMaxIpcTag = static_cast<size_t>(IpcTag::LAST);
 static_assert(kMaxIpcTag <= kMaxServiceCount, "kMaxServiceCount is too low");
 
diff --git a/sandbox/win/src/policy_engine_opcodes.cc b/sandbox/win/src/policy_engine_opcodes.cc
--- a/sandbox/win/src/policy_engine_opcodes.cc
+++ b/sandbox/win/src/policy_engine_opcodes.cc
@@ -78,17 +78,17 @@ EvalResult OpcodeEval<OP_ALWAYS_TRUE>(Po
 }
 
 //////////////////////////////////////////////////////////////////////////////
 // Opcode OpAction:
 // Does not require input parameter.
 // Argument 0 contains the actual action to return.
 
 PolicyOpcode* OpcodeFactory::MakeOpAction(EvalResult action, uint32_t options) {
-  PolicyOpcode* opcode = MakeBase(OP_ACTION, options, 0);
+  PolicyOpcode* opcode = MakeBase(OP_ACTION, options);
   if (!opcode)
     return nullptr;
   opcode->SetArgument(0, action);
   return opcode;
 }
 
 template <>
 EvalResult OpcodeEval<OP_ACTION>(PolicyOpcode* opcode,
diff --git a/sandbox/win/src/policy_params.h b/sandbox/win/src/policy_params.h
--- a/sandbox/win/src/policy_params.h
+++ b/sandbox/win/src/policy_params.h
@@ -43,11 +43,15 @@ POLPARAMS_BEGIN(OpenKey)
 POLPARAMS_END(OpenKey)
 
 // Policy parameter for name-based policies.
 POLPARAMS_BEGIN(HandleTarget)
   POLPARAM(NAME)
   POLPARAM(TARGET)
 POLPARAMS_END(HandleTarget)
 
+// Policy parameters where no parameter based checks are done.
+POLPARAMS_BEGIN(EmptyParams)
+POLPARAMS_END(EmptyParams)
+
 }  // namespace sandbox
 
 #endif  // SANDBOX_WIN_SRC_POLICY_PARAMS_H_
diff --git a/sandbox/win/src/sandbox.h b/sandbox/win/src/sandbox.h
--- a/sandbox/win/src/sandbox.h
+++ b/sandbox/win/src/sandbox.h
@@ -154,16 +154,19 @@ class TargetServices {
   // fails the current process could be terminated immediately.
   virtual void LowerToken() = 0;
 
   // Returns the ProcessState object. Through that object it's possible to have
   // information about the current state of the process, such as whether
   // LowerToken has been called or not.
   virtual ProcessState* GetState() = 0;
 
+  virtual ResultCode GetComplexLineBreaks(const WCHAR* text, uint32_t length,
+                                          uint8_t* break_before) = 0;
+
  protected:
   ~TargetServices() {}
 };
 
 class [[clang::lto_visibility_public]] PolicyInfo {
  public:
   // Returns a JSON representation of the policy snapshot.
   // This pointer has the same lifetime as this PolicyInfo object.
diff --git a/sandbox/win/src/sandbox_policy.h b/sandbox/win/src/sandbox_policy.h
--- a/sandbox/win/src/sandbox_policy.h
+++ b/sandbox/win/src/sandbox_policy.h
@@ -169,16 +169,19 @@ class TargetPolicy {
   // Modules patching `pattern` (see AllowFileAccess) can still be loaded under
   // Code-Integrity Guard (MITIGATION_FORCE_MS_SIGNED_BINS).
   [[nodiscard]] virtual ResultCode AllowExtraDlls(const wchar_t* pattern) = 0;
 
   // Adds a policy rule effective for processes spawned using this policy.
   // Fake gdi init to allow user32 and gdi32 to initialize under Win32 Lockdown.
   [[nodiscard]] virtual ResultCode SetFakeGdiInit() = 0;
 
+  // Adds a policy rule to allow complex line break brokering.
+  [[nodiscard]] virtual ResultCode AllowLineBreaking() = 0;
+
   // Adds a dll that will be unloaded in the target process before it gets
   // a chance to initialize itself. Typically, dlls that cause the target
   // to crash go here.
   virtual void AddDllToUnload(const wchar_t* dll_name) = 0;
 
   // Sets the integrity level of the process in the sandbox. Both the initial
   // token and the main token will be affected by this. If the integrity level
   // is set to a level higher than the current level, the sandbox will fail
diff --git a/sandbox/win/src/sandbox_policy_base.cc b/sandbox/win/src/sandbox_policy_base.cc
--- a/sandbox/win/src/sandbox_policy_base.cc
+++ b/sandbox/win/src/sandbox_policy_base.cc
@@ -26,16 +26,17 @@
 #include "base/win/win_util.h"
 #include "base/win/windows_version.h"
 #include "sandbox/features.h"
 #include "sandbox/win/src/acl.h"
 #include "sandbox/win/src/crosscall_server.h"
 #include "sandbox/win/src/filesystem_policy.h"
 #include "sandbox/win/src/interception.h"
 #include "sandbox/win/src/job.h"
+#include "sandbox/win/src/line_break_policy.h"
 #include "sandbox/win/src/named_pipe_policy.h"
 #include "sandbox/win/src/policy_broker.h"
 #include "sandbox/win/src/policy_engine_processor.h"
 #include "sandbox/win/src/policy_low_level.h"
 #include "sandbox/win/src/process_mitigations.h"
 #include "sandbox/win/src/process_mitigations_win32k_policy.h"
 #include "sandbox/win/src/process_thread_policy.h"
 #include "sandbox/win/src/restricted_token_utils.h"
@@ -281,16 +281,24 @@ ResultCode PolicyBase::AddRuleInternal(S
     if (!SignedPolicy::GenerateRules(pattern, PolicyMaker())) {
       NOTREACHED();
       return SBOX_ERROR_BAD_PARAMS;
     }
   }
   return SBOX_ALL_OK;
 }
 
+ResultCode ConfigBase::AllowLineBreaking() {
+  if (!LineBreakPolicy::GenerateRules(PolicyMaker())) {
+    NOTREACHED();
+    return SBOX_ERROR_BAD_PARAMS;
+  }
+  return SBOX_ALL_OK;
+}
+
 void ConfigBase::AddDllToUnload(const wchar_t* dll_name) {
   blocklisted_dlls_.push_back(dll_name);
 }
 
 ResultCode ConfigBase::SetIntegrityLevel(IntegrityLevel integrity_level) {
   if (app_container_)
     return SBOX_ERROR_BAD_PARAMS;
   integrity_level_ = integrity_level;
diff --git a/sandbox/win/src/sandbox_policy_base.h b/sandbox/win/src/sandbox_policy_base.h
--- a/sandbox/win/src/sandbox_policy_base.h
+++ b/sandbox/win/src/sandbox_policy_base.h
@@ -63,16 +63,17 @@ class ConfigBase final : public TargetCo
   ResultCode SetJobLevel(JobLevel job_level, uint32_t ui_exceptions) override;
   JobLevel GetJobLevel() const override;
   void SetJobMemoryLimit(size_t memory_limit) override;
   ResultCode AllowFileAccess(FileSemantics semantics,
                              const wchar_t* pattern) override;
   ResultCode AllowNamedPipes(const wchar_t* pattern) override;
   ResultCode AllowExtraDlls(const wchar_t* pattern) override;
   ResultCode SetFakeGdiInit() override;
+  ResultCode AllowLineBreaking() final;
   void AddDllToUnload(const wchar_t* dll_name) override;
   ResultCode SetIntegrityLevel(IntegrityLevel integrity_level) override;
   IntegrityLevel GetIntegrityLevel() const override;
   void SetDelayedIntegrityLevel(IntegrityLevel integrity_level) override;
   ResultCode SetLowBox(const wchar_t* sid) override;
   ResultCode SetProcessMitigations(MitigationFlags flags) override;
   MitigationFlags GetProcessMitigations() override;
   ResultCode SetDelayedProcessMitigations(MitigationFlags flags) override;
diff --git a/sandbox/win/src/target_services.cc b/sandbox/win/src/target_services.cc
--- a/sandbox/win/src/target_services.cc
+++ b/sandbox/win/src/target_services.cc
@@ -14,16 +14,17 @@
 
 #include <optional>
 #include "base/containers/span.h"
 #include "base/logging.h"
 #include "base/win/access_token.h"
 #include "sandbox/win/src/acl.h"
 #include "sandbox/win/src/crosscall_client.h"
 #include "sandbox/win/src/handle_closer_agent.h"
+#include "sandbox/win/src/line_break_interception.h"
 #include "sandbox/win/src/heap_helper.h"
 #include "sandbox/win/src/ipc_tags.h"
 #include "sandbox/win/src/process_mitigations.h"
 #include "sandbox/win/src/restricted_token_utils.h"
 #include "sandbox/win/src/sandbox.h"
 #include "sandbox/win/src/sandbox_nt_util.h"
 #include "sandbox/win/src/sandbox_types.h"
 #include "sandbox/win/src/sharedmem_ipc_client.h"
@@ -240,9 +241,15 @@ void ProcessState::SetRevertedToSelf() {
   if (process_state_ < ProcessStateInternal::REVERTED_TO_SELF)
     process_state_ = ProcessStateInternal::REVERTED_TO_SELF;
 }
 
 void ProcessState::SetCsrssConnected(bool csrss_connected) {
   csrss_connected_ = csrss_connected;
 }
 
+ResultCode TargetServicesBase::GetComplexLineBreaks(const WCHAR* text,
+                                                    uint32_t length,
+                                                    uint8_t* break_before) {
+  return sandbox::GetComplexLineBreaksProxy(text, length, break_before);
+}
+
 }  // namespace sandbox
diff --git a/sandbox/win/src/target_services.h b/sandbox/win/src/target_services.h
--- a/sandbox/win/src/target_services.h
+++ b/sandbox/win/src/target_services.h
@@ -48,16 +48,18 @@ class TargetServicesBase : public Target
   TargetServicesBase(const TargetServicesBase&) = delete;
   TargetServicesBase& operator=(const TargetServicesBase&) = delete;
 
   // Public interface of TargetServices. See comments in sandbox.h.
   ResultCode Init() override;
   absl::optional<base::span<const uint8_t>> GetDelegateData() override;
   void LowerToken() override;
   ProcessState* GetState() override;
+  ResultCode GetComplexLineBreaks(const WCHAR* text, uint32_t length,
+                                  uint8_t* break_before) final;
 
   // Factory method.
   static TargetServicesBase* GetInstance();
 
   // Sends a simple IPC Message that has a well-known answer. Returns true
   // if the IPC was successful and false otherwise. There are 2 versions of
   // this test: 1 and 2. The first one send a simple message while the
   // second one send a message with an in/out param.
diff --git a/sandbox/win/src/top_level_dispatcher.cc b/sandbox/win/src/top_level_dispatcher.cc
--- a/sandbox/win/src/top_level_dispatcher.cc
+++ b/sandbox/win/src/top_level_dispatcher.cc
@@ -14,16 +14,17 @@
 
 #include "base/check.h"
 #include "base/notreached.h"
 #include "sandbox/win/src/crosscall_server.h"
 #include "sandbox/win/src/filesystem_dispatcher.h"
 #include "sandbox/win/src/interception.h"
 #include "sandbox/win/src/internal_types.h"
 #include "sandbox/win/src/ipc_tags.h"
+#include "sandbox/win/src/line_break_dispatcher.h"
 #include "sandbox/win/src/named_pipe_dispatcher.h"
 #include "sandbox/win/src/process_mitigations_win32k_dispatcher.h"
 #include "sandbox/win/src/process_thread_dispatcher.h"
 #include "sandbox/win/src/sandbox_policy_base.h"
 #include "sandbox/win/src/signed_dispatcher.h"
 
 namespace sandbox {
 
@@ -46,16 +47,20 @@ TopLevelDispatcher::TopLevelDispatcher(P
   ipc_targets_[static_cast<size_t>(IpcTag::GDI_GDIDLLINITIALIZE)] = dispatcher;
   ipc_targets_[static_cast<size_t>(IpcTag::GDI_GETSTOCKOBJECT)] = dispatcher;
   ipc_targets_[static_cast<size_t>(IpcTag::USER_REGISTERCLASSW)] = dispatcher;
   process_mitigations_win32k_dispatcher_.reset(dispatcher);
 
   dispatcher = new SignedDispatcher(policy_);
   ipc_targets_[static_cast<size_t>(IpcTag::NTCREATESECTION)] = dispatcher;
   signed_dispatcher_.reset(dispatcher);
+
+  dispatcher = new LineBreakDispatcher(policy_);
+  ipc_targets_[static_cast<size_t>(IpcTag::GETCOMPLEXLINEBREAKS)] = dispatcher;
+  line_break_dispatcher_.reset(dispatcher);
 }
 
 TopLevelDispatcher::~TopLevelDispatcher() {}
 
 // When an IPC is ready in any of the targets we get called. We manage an array
 // of IPC dispatchers which are keyed on the IPC tag so we normally delegate
 // to the appropriate dispatcher unless we can handle the IPC call ourselves.     }
 Dispatcher* TopLevelDispatcher::OnMessageReady(IPCParams* ipc,
diff --git a/sandbox/win/src/top_level_dispatcher.h b/sandbox/win/src/top_level_dispatcher.h
--- a/sandbox/win/src/top_level_dispatcher.h
+++ b/sandbox/win/src/top_level_dispatcher.h
@@ -40,14 +40,15 @@ class TopLevelDispatcher : public Dispat
 
   raw_ptr<PolicyBase> policy_;
   std::unique_ptr<Dispatcher> filesystem_dispatcher_;
   std::unique_ptr<Dispatcher> named_pipe_dispatcher_;
   std::unique_ptr<Dispatcher> thread_process_dispatcher_;
   std::unique_ptr<Dispatcher> handle_dispatcher_;
   std::unique_ptr<Dispatcher> process_mitigations_win32k_dispatcher_;
   std::unique_ptr<Dispatcher> signed_dispatcher_;
+  std::unique_ptr<Dispatcher> line_break_dispatcher_;
   Dispatcher* ipc_targets_[kMaxIpcTag];
 };
 
 }  // namespace sandbox
 
 #endif  // SANDBOX_WIN_SRC_TOP_LEVEL_DISPATCHER_H_
