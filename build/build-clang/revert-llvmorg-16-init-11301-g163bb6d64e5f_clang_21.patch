From cf00b30288c4c81b2c6a5af01c38f236148777a0 Mon Sep 17 00:00:00 2001
From: Mike Hommey <mh@glandium.org>
Date: Tue, 28 Mar 2023 06:13:36 +0900
Subject: [PATCH] Revert "[Passes][VectorCombine] enable early run generally
 and try load folds"

This reverts commit 163bb6d64e5f1220777c3ec2a8b58c0666a74d91.
It causes various reftest regressions.
---
 llvm/lib/Passes/PassBuilderPipelines.cpp          |  7 ++++---
 llvm/lib/Transforms/Vectorize/VectorCombine.cpp   |  8 ++------
 9 files changed, 18 insertions(+), 19 deletions(-)

diff --git a/llvm/lib/Passes/PassBuilderPipelines.cpp b/llvm/lib/Passes/PassBuilderPipelines.cpp
index 07db107325f0..40045629af06 100644
--- a/llvm/lib/Passes/PassBuilderPipelines.cpp
+++ b/llvm/lib/Passes/PassBuilderPipelines.cpp
@@ -729,9 +729,10 @@ PassBuilder::buildFunctionSimplificationPipeline(OptimizationLevel Level,
   // Delete small array after loop unroll.
   FPM.addPass(SROAPass(SROAOptions::ModifyCFG));
 
-  // Try vectorization/scalarization transforms that are both improvements
-  // themselves and can allow further folds with GVN and InstCombine.
-  FPM.addPass(VectorCombinePass(/*TryEarlyFoldsOnly=*/true));
+  // The matrix extension can introduce large vector operations early, which can
+  // benefit from running vector-combine early on.
+  if (EnableMatrix)
+    FPM.addPass(VectorCombinePass(/*TryEarlyFoldsOnly=*/true));
 
   // Eliminate redundancies.
   FPM.addPass(MergedLoadStoreMotionPass());
diff --git a/llvm/lib/Transforms/Vectorize/VectorCombine.cpp b/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
index 019d79567b4a..b3e0f4cf0514 100644
--- a/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
+++ b/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
@@ -3500,23 +3500,6 @@ bool VectorCombine::run() {
 
     LLVM_DEBUG(dbgs() << "VC: Visiting: " << I << '\n');
 
-    // These folds should be beneficial regardless of when this pass is run
-    // in the optimization pipeline.
-    // The type checking is for run-time efficiency. We can avoid wasting time
-    // dispatching to folding functions if there's no chance of matching.
-    if (IsFixedVectorType) {
-      switch (Opcode) {
-      case Instruction::InsertElement:
-        MadeChange |= vectorizeLoadInsert(I);
-        break;
-      case Instruction::ShuffleVector:
-        MadeChange |= widenSubvectorLoad(I);
-        break;
-      default:
-        break;
-      }
-    }
-
     // This transform works with scalable and fixed vectors
     // TODO: Identify and allow other scalable transforms
     if (IsVectorType) {
@@ -3540,11 +3523,13 @@ bool VectorCombine::run() {
     if (IsFixedVectorType) {
       switch (Opcode) {
       case Instruction::InsertElement:
+        MadeChange |= vectorizeLoadInsert(I);
         MadeChange |= foldInsExtFNeg(I);
         MadeChange |= foldInsExtBinop(I);
         MadeChange |= foldInsExtVectorToShuffle(I);
         break;
       case Instruction::ShuffleVector:
+        MadeChange |= widenSubvectorLoad(I);
         MadeChange |= foldPermuteOfBinops(I);
         MadeChange |= foldShuffleOfBinops(I);
         MadeChange |= foldShuffleOfSelects(I);
-- 
2.47.0.1.g59ce1bf855

