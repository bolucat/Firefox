// This file was autogenerated by the `uniffi-bindgen-gecko-js` crate.
// Trust me, you don't want to mess with it!

import { UniFFITypeError } from "moz-src:///toolkit/components/uniffi-js/js/UniFFI.sys.mjs";

// Objects intended to be used in the unit tests
export var UnitTestObjs = {};
/**
 * Handler for a single UniFFI CallbackInterface
 *
 * This class stores objects that implement a callback interface in a handle
 * map, allowing them to be referenced by the Rust code using an integer
 * handle.
 *
 * While the callback object is stored in the map, it allows the Rust code to
 * call methods on the object using the callback object handle, a method id,
 * and an ArrayBuffer packed with the method arguments.
 *
 * When the Rust code drops its reference, it sends a call with the methodId=0,
 * which causes callback object to be removed from the map.
 */
class UniFFICallbackHandler {
    #name;
    #interfaceId;
    #handleCounter;
    #handleMap;
    #methodHandlers;
    #allowNewCallbacks

    /**
     * Create a UniFFICallbackHandler
     * @param {string} name - Human-friendly name for this callback interface
     * @param {int} interfaceId - Interface ID for this CallbackInterface.
     * @param {UniFFICallbackMethodHandler[]} methodHandlers -- UniFFICallbackHandler for each method, in the same order as the UDL file
     */
     constructor(name, interfaceId, methodHandlers) {
        this.#name = name;
        this.#interfaceId = interfaceId;
        this.#handleCounter = 0;
        this.#handleMap = new Map();
        this.#methodHandlers = methodHandlers;
        this.#allowNewCallbacks = true;

        UniFFIScaffolding.registerCallbackHandler(this.#interfaceId, this);
        Services.obs.addObserver(this, "xpcom-shutdown");
     }

    /**
     * Store a callback object in the handle map and return the handle
     *
     * @param {obj} callbackObj - Object that implements the callback interface
     * @returns {int} - Handle for this callback object, this is what gets passed back to Rust.
     */
    storeCallbackObj(callbackObj) {
        if (!this.#allowNewCallbacks) {
            throw new UniFFIError(`No new callbacks allowed for ${this.#name}`);
        }
        // Increment first.  This way handles start at `1` and we can use `0` to represent a NULL
        // handle.
        this.#handleCounter += 1;
        const handle = this.#handleCounter;
        this.#handleMap.set(handle, new UniFFICallbackHandleMapEntry(callbackObj, Components.stack.caller.formattedStack.trim()));
        return handle;
    }

    /**
     * Get a previously stored callback object
     *
     * @param {int} handle - Callback object handle, returned from `storeCallbackObj()`
     * @returns {obj} - Callback object
     */
    getCallbackObj(handle) {
        const callbackObj = this.#handleMap.get(handle).callbackObj;
        if (callbackObj === undefined) {
            throw new UniFFIError(`${this.#name}: invalid callback handle id: ${handle}`);
        }
        return callbackObj;
    }

    /**
     * Get a UniFFICallbackMethodHandler
     *
     * @param {int} methodId - index of the method
     * @returns {UniFFICallbackMethodHandler}
     */
    getMethodHandler(methodId) {
        const methodHandler = this.#methodHandlers[methodId];
        if (methodHandler === undefined) {
            throw new UniFFIError(`${this.#name}: invalid method id: ${methodId}`)
        }
        return methodHandler;
    }

    /**
     * Set if new callbacks are allowed for this handler
     *
     * This is called with false during shutdown to ensure the callback maps don't
     * prevent JS objects from being GCed.
     */
    setAllowNewCallbacks(allow) {
        this.#allowNewCallbacks = allow
    }

    /**
     * Check if there are any registered callbacks in the handle map
     *
     * This is used in the unit tests
     */
    hasRegisteredCallbacks() {
        return this.#handleMap.size > 0;
    }
    /**
     * Check that no callbacks are currently registered
     *
     * If there are callbacks registered a UniFFIError will be thrown.  This is
     * called during shutdown to generate an alert if there are leaked callback
     * interfaces.
     */
    assertNoRegisteredCallbacks() {
        if (this.#handleMap.size > 0) {
            const entry = this.#handleMap.values().next().value;
            throw new UniFFIError(`UniFFI interface ${this.#name} has ${this.#handleMap.size} registered callbacks at xpcom-shutdown. This likely indicates a UniFFI callback leak.\nStack trace for the first leaked callback:\n${entry.stackTrace}.`);
        }
    }

    /**
     * Invoke a method on a stored callback object
     * @param {int} handle - Object handle
     * @param {int} methodId - Method index (0-based)
     * @param {UniFFIScaffoldingValue[]} args - Arguments to pass to the method
     */
    call(handle, methodId, ...args) {
        try {
            const callbackObj = this.getCallbackObj(handle);
            const methodHandler = this.getMethodHandler(methodId);
            methodHandler.call(callbackObj, args);
        } catch (e) {
            console.error(`internal error invoking callback: ${e}`)
        }
    }

    /**
     * Invoke a method on a stored callback object
     * @param {int} handle - Object handle
     * @param {int} methodId - Method index (0-based)
     * @param {UniFFIScaffoldingValue[]} args - Arguments to pass to the method
     */
    async callAsync(handle, methodId, ...args) {
        const callbackObj = this.getCallbackObj(handle);
        const methodHandler = this.getMethodHandler(methodId);
        try {
            const returnValue = await methodHandler.call(callbackObj, args);
            return methodHandler.lowerReturn(returnValue);
        } catch(e) {
            return methodHandler.lowerError(e)
        }
    }

    /**
     * Destroy a stored callback object
     * @param {int} handle - Object handle
     */
    destroy(handle) {
        this.#handleMap.delete(handle);
    }

    /**
     * xpcom-shutdown observer method
     *
     * This handles:
     *  - Deregistering ourselves as the UniFFI callback handler
     *  - Checks for any leftover stored callbacks which indicate memory leaks
     */
    observe(aSubject, aTopic, aData) {
        if (aTopic == "xpcom-shutdown") {
            try {
                this.setAllowNewCallbacks(false);
                this.assertNoRegisteredCallbacks();
                UniFFIScaffolding.deregisterCallbackHandler(this.#interfaceId);
            } catch (ex) {
                console.error(`UniFFI Callback interface error during xpcom-shutdown: ${ex}`);
                Cc["@mozilla.org/xpcom/debug;1"]
                    .getService(Ci.nsIDebug2)
                    .abort(ex.filename, ex.lineNumber);
            }
         }
    }
}

/**
 * Handles calling a single method for a callback interface
 */
class UniFFICallbackMethodHandler {
    #name;
    #argsConverters;
    #returnConverter;
    #errorConverter;

    /**
     * Create a UniFFICallbackMethodHandler

     * @param {string} name -- Name of the method to call on the callback object
     * @param {FfiConverter[]} argsConverters - FfiConverter for each argument type
     */
    constructor(name, argsConverters, returnConverter, errorConverter) {
        this.#name = name;
        this.#argsConverters = argsConverters;
        this.#returnConverter = returnConverter;
        this.#errorConverter = errorConverter;
    }

     call(callbackObj, args) {
        const convertedArgs = this.#argsConverters.map((converter, i) => converter.lift(args[i]));
        return callbackObj[this.#name](...convertedArgs);
    }

    lowerReturn(returnValue) {
        return {
            code: "success",
            data: this.#returnConverter(returnValue),
        };
    }

    lowerError(error) {
        return {
            code: "error",
            data: this.#errorConverter(error),
        };
    }

    toString() {
      return `CallbackMethodHandler(${this.#name})`
    }
}

/**
 * UniFFICallbackHandler.handleMap entry
 *
 * @property callbackObj - Callback object, this must implement the callback interface.
 * @property {string} stackTrace - Stack trace from when the callback object was registered.  This is used to proved extra context when debugging leaked callback objects.
 */
class UniFFICallbackHandleMapEntry {
    constructor(callbackObj, stackTrace) {
        this.callbackObj = callbackObj;
        this.stackTrace = stackTrace
    }
}


let lazy = {};

ChromeUtils.defineLazyGetter(lazy, "decoder", () => new TextDecoder());
ChromeUtils.defineLazyGetter(lazy, "encoder", () => new TextEncoder());

// Write/Read data to/from an ArrayBuffer
class ArrayBufferDataStream {
    constructor(arrayBuffer) {
        this.dataView = new DataView(arrayBuffer);
        this.pos = 0;
    }

    readUint8() {
        let rv = this.dataView.getUint8(this.pos);
        this.pos += 1;
        return rv;
    }

    writeUint8(value) {
        this.dataView.setUint8(this.pos, value);
        this.pos += 1;
    }

    readUint16() {
        let rv = this.dataView.getUint16(this.pos);
        this.pos += 2;
        return rv;
    }

    writeUint16(value) {
        this.dataView.setUint16(this.pos, value);
        this.pos += 2;
    }

    readUint32() {
        let rv = this.dataView.getUint32(this.pos);
        this.pos += 4;
        return rv;
    }

    writeUint32(value) {
        this.dataView.setUint32(this.pos, value);
        this.pos += 4;
    }

    readUint64() {
        let rv = this.dataView.getBigUint64(this.pos);
        this.pos += 8;
        return Number(rv);
    }

    writeUint64(value) {
        this.dataView.setBigUint64(this.pos, BigInt(value));
        this.pos += 8;
    }


    readInt8() {
        let rv = this.dataView.getInt8(this.pos);
        this.pos += 1;
        return rv;
    }

    writeInt8(value) {
        this.dataView.setInt8(this.pos, value);
        this.pos += 1;
    }

    readInt16() {
        let rv = this.dataView.getInt16(this.pos);
        this.pos += 2;
        return rv;
    }

    writeInt16(value) {
        this.dataView.setInt16(this.pos, value);
        this.pos += 2;
    }

    readInt32() {
        let rv = this.dataView.getInt32(this.pos);
        this.pos += 4;
        return rv;
    }

    writeInt32(value) {
        this.dataView.setInt32(this.pos, value);
        this.pos += 4;
    }

    readInt64() {
        let rv = this.dataView.getBigInt64(this.pos);
        this.pos += 8;
        return Number(rv);
    }

    writeInt64(value) {
        this.dataView.setBigInt64(this.pos, BigInt(value));
        this.pos += 8;
    }

    readFloat32() {
        let rv = this.dataView.getFloat32(this.pos);
        this.pos += 4;
        return rv;
    }

    writeFloat32(value) {
        this.dataView.setFloat32(this.pos, value);
        this.pos += 4;
    }

    readFloat64() {
        let rv = this.dataView.getFloat64(this.pos);
        this.pos += 8;
        return rv;
    }

    writeFloat64(value) {
        this.dataView.setFloat64(this.pos, value);
        this.pos += 8;
    }


    writeString(value) {
      // Note: in order to efficiently write this data, we first write the
      // string data, reserving 4 bytes for the size.
      const dest = new Uint8Array(this.dataView.buffer, this.pos + 4);
      const encodeResult = lazy.encoder.encodeInto(value, dest);
      if (encodeResult.read != value.length) {
        throw new UniFFIError(
            "writeString: out of space when writing to ArrayBuffer.  Did the computeSize() method returned the wrong result?"
        );
      }
      const size = encodeResult.written;
      // Next, go back and write the size before the string data
      this.dataView.setUint32(this.pos, size);
      // Finally, advance our position past both the size and string data
      this.pos += size + 4;
    }

    readString() {
      const size = this.readUint32();
      const source = new Uint8Array(this.dataView.buffer, this.pos, size)
      const value = lazy.decoder.decode(source);
      this.pos += size;
      return value;
    }

    readBytes() {
      const size = this.readInt32();
      const bytes = new Uint8Array(this.dataView.buffer, this.pos, size);
      this.pos += size;
      return bytes
    }

    writeBytes(value) {
      this.writeUint32(value.length);
      value.forEach((elt) => {
        this.writeUint8(elt);
      })
    }

    // Reads a pointer from the data stream
    // UniFFI Pointers are **always** 8 bytes long. That is enforced
    // by the C++ and Rust Scaffolding code.
    readPointer(pointerId) {
        const res = UniFFIScaffolding.readPointer(pointerId, this.dataView.buffer, this.pos);
        this.pos += 8;
        return res;
    }

    // Writes a pointer into the data stream
    // UniFFI Pointers are **always** 8 bytes long. That is enforced
    // by the C++ and Rust Scaffolding code.
    writePointer(pointerId, value) {
        UniFFIScaffolding.writePointer(pointerId, value, this.dataView.buffer, this.pos);
        this.pos += 8;
    }
}

function handleRustResult(result, liftCallback, liftErrCallback) {
    switch (result.code) {
        case "success":
            return liftCallback(result.data);

        case "error":
            throw liftErrCallback(result.data);

        case "internal-error":
            if (result.data) {
                throw new UniFFIInternalError(FfiConverterString.lift(result.data));
            } else {
                throw new UniFFIInternalError("Unknown error");
            }

        default:
            throw new UniFFIError(`Unexpected status code: ${result.code}`);
    }
}

class UniFFIError {
    constructor(message) {
        this.message = message;
    }

    toString() {
        return `UniFFIError: ${this.message}`
    }
}

class UniFFIInternalError extends UniFFIError {}

// Base class for FFI converters
class FfiConverter {
    // throw `UniFFITypeError` if a value to be converted has an invalid type
    static checkType(value) {
        if (value === undefined ) {
            throw new UniFFITypeError(`undefined`);
        }
        if (value === null ) {
            throw new UniFFITypeError(`null`);
        }
    }
}

// Base class for FFI converters that lift/lower by reading/writing to an ArrayBuffer
class FfiConverterArrayBuffer extends FfiConverter {
    static lift(buf) {
        return this.read(new ArrayBufferDataStream(buf));
    }

    static lower(value) {
        const buf = new ArrayBuffer(this.computeSize(value));
        const dataStream = new ArrayBufferDataStream(buf);
        this.write(dataStream, value);
        return buf;
    }

    /**
     * Computes the size of the value.
     *
     * @param {*} _value
     * @return {number}
     */
    static computeSize(_value) {
        throw new UniFFIInternalError("computeSize() should be declared in the derived class");
    }

    /**
     * Reads the type from a data stream.
     *
     * @param {ArrayBufferDataStream} _dataStream
     * @returns {any}
     */
    static read(_dataStream) {
        throw new UniFFIInternalError("read() should be declared in the derived class");
    }

    /**
     * Writes the type to a data stream.
     *
     * @param {ArrayBufferDataStream} _dataStream
     * @param {any} _value
     */
    static write(_dataStream, _value) {
        throw new UniFFIInternalError("write() should be declared in the derived class");
    }

}

// Symbols that are used to ensure that Object constructors
// can only be used with a proper UniFFI pointer
const uniffiObjectPtr = Symbol("uniffiObjectPtr");
const constructUniffiObject = Symbol("constructUniffiObject");
UnitTestObjs.uniffiObjectPtr = uniffiObjectPtr;
/**
 * registerEventSink
 * @param {string} target
 * @param {TracingLevel} level
 * @param {EventSink} sink
 */
export function registerEventSink(
    target, 
    level, 
    sink) {
   
FfiConverterString.checkType(target);
FfiConverterTypeTracingLevel.checkType(level);
FfiConverterTypeEventSink.checkType(sink);
const result = UniFFIScaffolding.callSync(
    91, // uniffi_tracing_support_fn_func_register_event_sink
    FfiConverterString.lower(target),
    FfiConverterTypeTracingLevel.lower(level),
    FfiConverterTypeEventSink.lower(sink),
)
return handleRustResult(
    result,
    (result) => undefined,
    null,
)
}

/**
 * unregisterEventSink
 * @param {string} target
 */
export function unregisterEventSink(
    target) {
   
FfiConverterString.checkType(target);
const result = UniFFIScaffolding.callSync(
    92, // uniffi_tracing_support_fn_func_unregister_event_sink
    FfiConverterString.lower(target),
)
return handleRustResult(
    result,
    (result) => undefined,
    null,
)
}



/**
 * TracingLevel
 */
export const TracingLevel = {
    /**
     * ERROR
     */
    ERROR: 0,
    /**
     * WARN
     */
    WARN: 1,
    /**
     * INFO
     */
    INFO: 2,
    /**
     * DEBUG
     */
    DEBUG: 3,
    /**
     * TRACE
     */
    TRACE: 4,
};
Object.freeze(TracingLevel);

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeTracingLevel extends FfiConverterArrayBuffer {
    static #validValues = Object.values(TracingLevel)

    static read(dataStream) {
        // Use sequential indices (1-based) for the wire format to match the Rust scaffolding
        switch (dataStream.readInt32()) {
            case 1:
                return TracingLevel.ERROR
            case 2:
                return TracingLevel.WARN
            case 3:
                return TracingLevel.INFO
            case 4:
                return TracingLevel.DEBUG
            case 5:
                return TracingLevel.TRACE
            default:
                throw new UniFFITypeError("Unknown TracingLevel variant");
        }
    }

    static write(dataStream, value) {
        // Use sequential indices (1-based) for the wire format to match the Rust scaffolding
        if (value === TracingLevel.ERROR) {
            dataStream.writeInt32(1);
            return;
        }
        if (value === TracingLevel.WARN) {
            dataStream.writeInt32(2);
            return;
        }
        if (value === TracingLevel.INFO) {
            dataStream.writeInt32(3);
            return;
        }
        if (value === TracingLevel.DEBUG) {
            dataStream.writeInt32(4);
            return;
        }
        if (value === TracingLevel.TRACE) {
            dataStream.writeInt32(5);
            return;
        }
        throw new UniFFITypeError("Unknown TracingLevel variant");
    }

    static computeSize(value) {
        return 4;
    }

    static checkType(value) {
      // Check that the value is a valid enum variant
      if (!this.#validValues.includes(value)) {
          throw new UniFFITypeError(`${value} is not a valid value for TracingLevel`);
      }
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterString extends FfiConverter {
    static checkType(value) {
        super.checkType(value);
        if (typeof value !== "string") {
            throw new UniFFITypeError(`${value} is not a string`);
        }
    }

    static lift(buf) {
        const utf8Arr = new Uint8Array(buf);
        return lazy.decoder.decode(utf8Arr);
    }
    static lower(value) {
        return lazy.encoder.encode(value).buffer;
    }

    static write(dataStream, value) {
        dataStream.writeString(value);
    }

    static read(dataStream) {
        return dataStream.readString();
    }

    static computeSize(value) {
        return 4 + lazy.encoder.encode(value).length
    }
}
export class FfiConverterTypeTracingJsonValue extends FfiConverter {
    static lift(value) {
        return FfiConverterString.lift(value);
    }

    static lower(value) {
        return FfiConverterString.lower(value);
    }

    static write(dataStream, value) {
        FfiConverterString.write(dataStream, value);
    }

    static read(dataStream) {
        const builtinVal = FfiConverterString.read(dataStream);
        return builtinVal;
    }

    static computeSize(value) {
        return FfiConverterString.computeSize(value);
    }

    static checkType(value) {
        if (value === null || value === undefined) {
            throw new TypeError("value is null or undefined");
        }
    }
}
/**
 * TracingEvent
 */
export class TracingEvent {
    constructor(
        {
            level, 
            target, 
            name, 
            message, 
            fields
        } = {
            level: undefined, 
            target: undefined, 
            name: undefined, 
            message: undefined, 
            fields: undefined
        }
    ) {
        try {
            FfiConverterTypeTracingLevel.checkType(level)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("level");
            }
            throw e;
        }
        try {
            FfiConverterString.checkType(target)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("target");
            }
            throw e;
        }
        try {
            FfiConverterString.checkType(name)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("name");
            }
            throw e;
        }
        try {
            FfiConverterString.checkType(message)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("message");
            }
            throw e;
        }
        try {
            FfiConverterTypeTracingJsonValue.checkType(fields)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("fields");
            }
            throw e;
        }
        /**
         * level
         */
        this.level = level;
        /**
         * target
         */
        this.target = target;
        /**
         * name
         */
        this.name = name;
        /**
         * message
         */
        this.message = message;
        /**
         * fields
         */
        this.fields = fields;
    }

    equals(other) {
        return (
            this.level == other.level
            && this.target == other.target
            && this.name == other.name
            && this.message == other.message
            && this.fields == other.fields
        )
    }
}

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeTracingEvent extends FfiConverterArrayBuffer {
    static read(dataStream) {
        return new TracingEvent({
            level: FfiConverterTypeTracingLevel.read(dataStream),
            target: FfiConverterString.read(dataStream),
            name: FfiConverterString.read(dataStream),
            message: FfiConverterString.read(dataStream),
            fields: FfiConverterTypeTracingJsonValue.read(dataStream),
        });
    }
    static write(dataStream, value) {
        FfiConverterTypeTracingLevel.write(dataStream, value.level);
        FfiConverterString.write(dataStream, value.target);
        FfiConverterString.write(dataStream, value.name);
        FfiConverterString.write(dataStream, value.message);
        FfiConverterTypeTracingJsonValue.write(dataStream, value.fields);
    }

    static computeSize(value) {
        let totalSize = 0;
        totalSize += FfiConverterTypeTracingLevel.computeSize(value.level);
        totalSize += FfiConverterString.computeSize(value.target);
        totalSize += FfiConverterString.computeSize(value.name);
        totalSize += FfiConverterString.computeSize(value.message);
        totalSize += FfiConverterTypeTracingJsonValue.computeSize(value.fields);
        return totalSize
    }

    static checkType(value) {
        super.checkType(value);
        if (!(value instanceof TracingEvent)) {
            throw new UniFFITypeError(`Expected 'TracingEvent', found '${typeof value}'`);
        }
        try {
            FfiConverterTypeTracingLevel.checkType(value.level);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".level");
            }
            throw e;
        }
        try {
            FfiConverterString.checkType(value.target);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".target");
            }
            throw e;
        }
        try {
            FfiConverterString.checkType(value.name);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".name");
            }
            throw e;
        }
        try {
            FfiConverterString.checkType(value.message);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".message");
            }
            throw e;
        }
        try {
            FfiConverterTypeTracingJsonValue.checkType(value.fields);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".fields");
            }
            throw e;
        }
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterTypeEventSink extends FfiConverter {
    static lower(callbackObj) {
        return uniffiCallbackHandlerTracingEventSink.storeCallbackObj(callbackObj)
    }

    static lift(handleId) {
        return uniffiCallbackHandlerTracingEventSink.getCallbackObj(handleId)
    }

    static read(dataStream) {
        return this.lift(dataStream.readInt64())
    }

    static write(dataStream, callbackObj) {
        dataStream.writeInt64(this.lower(callbackObj))
    }

    static computeSize(callbackObj) {
        return 8;
    }
}const uniffiCallbackHandlerTracingEventSink = new UniFFICallbackHandler(
    "EventSink",
    3,
    [
        new UniFFICallbackMethodHandler(
            "onEvent",
            [
                FfiConverterTypeTracingEvent,
            ],
            (result) => undefined,
            (e) => {
              throw e;
            }
        ),
    ]
);

// Allow the shutdown-related functionality to be tested in the unit tests
UnitTestObjs.uniffiCallbackHandlerTracingEventSink = uniffiCallbackHandlerTracingEventSink;
// Export the FFIConverter object to make external types work.
export class FfiConverterUInt8 extends FfiConverter {
    static checkType(value) {
        super.checkType(value);
        if (!Number.isInteger(value)) {
            throw new UniFFITypeError(`${value} is not an integer`);
        }
        if (value < 0 || value > 256) {
            throw new UniFFITypeError(`${value} exceeds the U8 bounds`);
        }
    }
    static computeSize(_value) {
        return 1;
    }
    static lift(value) {
        return value;
    }
    static lower(value) {
        return value;
    }
    static write(dataStream, value) {
        dataStream.writeUint8(value)
    }
    static read(dataStream) {
        return dataStream.readUint8()
    }
}
