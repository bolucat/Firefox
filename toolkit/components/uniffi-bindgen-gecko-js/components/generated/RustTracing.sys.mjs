// This file was autogenerated by the `uniffi-bindgen-gecko-js` crate.
// Trust me, you don't want to mess with it!

import {
  ArrayBufferDataStream,
  FfiConverter,
  FfiConverterArrayBuffer,
  FfiConverterInt8,
  FfiConverterUInt8,
  FfiConverterInt16,
  FfiConverterUInt16,
  FfiConverterInt32,
  FfiConverterUInt32,
  FfiConverterInt64,
  FfiConverterUInt64,
  FfiConverterFloat32,
  FfiConverterFloat64,
  FfiConverterBoolean,
  FfiConverterBytes,
  FfiConverterString,
  UniFFICallbackHandler,
  UniFFICallbackMethodHandler,
  UniFFIError,
  UniFFIInternalError,
  UniFFITypeError,
  constructUniffiObject,
  handleRustResult,
  uniffiObjectPtr,
} from "moz-src:///toolkit/components/uniffi-js/js/UniFFI.sys.mjs";

// Objects intended to be used in the unit tests
export var UnitTestObjs = {
    uniffiObjectPtr,
};
/**
 * registerEventSink
 * @param {string} target
 * @param {TracingLevel} level
 * @param {EventSink} sink
 */
export function registerEventSink(
    target, 
    level, 
    sink) {
   
FfiConverterString.checkType(target);
FfiConverterTypeTracingLevel.checkType(level);
FfiConverterTypeEventSink.checkType(sink);
const result = UniFFIScaffolding.callSync(
    89, // uniffi_tracing_support_fn_func_register_event_sink
    FfiConverterString.lower(target),
    FfiConverterTypeTracingLevel.lower(level),
    FfiConverterTypeEventSink.lower(sink),
)
return handleRustResult(
    result,
    (result) => undefined,
    null,
)
}

/**
 * registerMinLevelEventSink
 * @param {TracingLevel} level
 * @param {EventSink} sink
 */
export function registerMinLevelEventSink(
    level, 
    sink) {
   
FfiConverterTypeTracingLevel.checkType(level);
FfiConverterTypeEventSink.checkType(sink);
const result = UniFFIScaffolding.callSync(
    90, // uniffi_tracing_support_fn_func_register_min_level_event_sink
    FfiConverterTypeTracingLevel.lower(level),
    FfiConverterTypeEventSink.lower(sink),
)
return handleRustResult(
    result,
    (result) => undefined,
    null,
)
}

/**
 * unregisterEventSink
 * @param {string} target
 */
export function unregisterEventSink(
    target) {
   
FfiConverterString.checkType(target);
const result = UniFFIScaffolding.callSync(
    91, // uniffi_tracing_support_fn_func_unregister_event_sink
    FfiConverterString.lower(target),
)
return handleRustResult(
    result,
    (result) => undefined,
    null,
)
}

/**
 * Remove the sink registered with [register_min_level_event_sink], if any.
 */
export function unregisterMinLevelEventSink() {
   
const result = UniFFIScaffolding.callSync(
    92, // uniffi_tracing_support_fn_func_unregister_min_level_event_sink
)
return handleRustResult(
    result,
    (result) => undefined,
    null,
)
}



/**
 * TracingLevel
 */
export const TracingLevel = {
    /**
     * ERROR
     */
    ERROR: 0,
    /**
     * WARN
     */
    WARN: 1,
    /**
     * INFO
     */
    INFO: 2,
    /**
     * DEBUG
     */
    DEBUG: 3,
    /**
     * TRACE
     */
    TRACE: 4,
};
Object.freeze(TracingLevel);

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeTracingLevel extends FfiConverterArrayBuffer {
    static #validValues = Object.values(TracingLevel)

    static read(dataStream) {
        // Use sequential indices (1-based) for the wire format to match the Rust scaffolding
        switch (dataStream.readInt32()) {
            case 1:
                return TracingLevel.ERROR
            case 2:
                return TracingLevel.WARN
            case 3:
                return TracingLevel.INFO
            case 4:
                return TracingLevel.DEBUG
            case 5:
                return TracingLevel.TRACE
            default:
                throw new UniFFITypeError("Unknown TracingLevel variant");
        }
    }

    static write(dataStream, value) {
        // Use sequential indices (1-based) for the wire format to match the Rust scaffolding
        if (value === TracingLevel.ERROR) {
            dataStream.writeInt32(1);
            return;
        }
        if (value === TracingLevel.WARN) {
            dataStream.writeInt32(2);
            return;
        }
        if (value === TracingLevel.INFO) {
            dataStream.writeInt32(3);
            return;
        }
        if (value === TracingLevel.DEBUG) {
            dataStream.writeInt32(4);
            return;
        }
        if (value === TracingLevel.TRACE) {
            dataStream.writeInt32(5);
            return;
        }
        throw new UniFFITypeError("Unknown TracingLevel variant");
    }

    static computeSize(value) {
        return 4;
    }

    static checkType(value) {
      // Check that the value is a valid enum variant
      if (!this.#validValues.includes(value)) {
          throw new UniFFITypeError(`${value} is not a valid value for TracingLevel`);
      }
    }
}


export class FfiConverterTypeTracingJsonValue extends FfiConverter {
    static lift(value) {
        return FfiConverterString.lift(value);
    }

    static lower(value) {
        return FfiConverterString.lower(value);
    }

    static write(dataStream, value) {
        FfiConverterString.write(dataStream, value);
    }

    static read(dataStream) {
        const builtinVal = FfiConverterString.read(dataStream);
        return builtinVal;
    }

    static computeSize(value) {
        return FfiConverterString.computeSize(value);
    }

    static checkType(value) {
        if (value === null || value === undefined) {
            throw new TypeError("value is null or undefined");
        }
    }
}
/**
 * TracingEvent
 */
export class TracingEvent {
    constructor(
        {
            level, 
            target, 
            name, 
            message, 
            fields
        } = {
            level: undefined, 
            target: undefined, 
            name: undefined, 
            message: undefined, 
            fields: undefined
        }
    ) {
        try {
            FfiConverterTypeTracingLevel.checkType(level)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("level");
            }
            throw e;
        }
        try {
            FfiConverterString.checkType(target)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("target");
            }
            throw e;
        }
        try {
            FfiConverterString.checkType(name)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("name");
            }
            throw e;
        }
        try {
            FfiConverterString.checkType(message)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("message");
            }
            throw e;
        }
        try {
            FfiConverterTypeTracingJsonValue.checkType(fields)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("fields");
            }
            throw e;
        }
        /**
         * level
         */
        this.level = level;
        /**
         * target
         */
        this.target = target;
        /**
         * name
         */
        this.name = name;
        /**
         * message
         */
        this.message = message;
        /**
         * fields
         */
        this.fields = fields;
    }

    equals(other) {
        return (
            this.level == other.level
            && this.target == other.target
            && this.name == other.name
            && this.message == other.message
            && this.fields == other.fields
        )
    }
}

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeTracingEvent extends FfiConverterArrayBuffer {
    static read(dataStream) {
        return new TracingEvent({
            level: FfiConverterTypeTracingLevel.read(dataStream),
            target: FfiConverterString.read(dataStream),
            name: FfiConverterString.read(dataStream),
            message: FfiConverterString.read(dataStream),
            fields: FfiConverterTypeTracingJsonValue.read(dataStream),
        });
    }
    static write(dataStream, value) {
        FfiConverterTypeTracingLevel.write(dataStream, value.level);
        FfiConverterString.write(dataStream, value.target);
        FfiConverterString.write(dataStream, value.name);
        FfiConverterString.write(dataStream, value.message);
        FfiConverterTypeTracingJsonValue.write(dataStream, value.fields);
    }

    static computeSize(value) {
        let totalSize = 0;
        totalSize += FfiConverterTypeTracingLevel.computeSize(value.level);
        totalSize += FfiConverterString.computeSize(value.target);
        totalSize += FfiConverterString.computeSize(value.name);
        totalSize += FfiConverterString.computeSize(value.message);
        totalSize += FfiConverterTypeTracingJsonValue.computeSize(value.fields);
        return totalSize
    }

    static checkType(value) {
        super.checkType(value);
        if (!(value instanceof TracingEvent)) {
            throw new UniFFITypeError(`Expected 'TracingEvent', found '${typeof value}'`);
        }
        try {
            FfiConverterTypeTracingLevel.checkType(value.level);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".level");
            }
            throw e;
        }
        try {
            FfiConverterString.checkType(value.target);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".target");
            }
            throw e;
        }
        try {
            FfiConverterString.checkType(value.name);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".name");
            }
            throw e;
        }
        try {
            FfiConverterString.checkType(value.message);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".message");
            }
            throw e;
        }
        try {
            FfiConverterTypeTracingJsonValue.checkType(value.fields);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".fields");
            }
            throw e;
        }
    }
}

/**
 * EventSink
 */
export class EventSink {
    /**
     * onEvent
     * @param {TracingEvent} event
     */
    onEvent(
        event) {
      throw Error("onEvent not implemented");
    }

}

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeEventSink extends FfiConverter {
    static lower(callbackObj) {
        if (!(callbackObj instanceof EventSink)) {
            throw new UniFFITypeError("expected 'EventSink' subclass");
        }
        return uniffiCallbackHandlerTracingEventSink.storeCallbackObj(callbackObj)
    }

    static lift(handleId) {
        return uniffiCallbackHandlerTracingEventSink.getCallbackObj(handleId)
    }

    static read(dataStream) {
        return this.lift(dataStream.readInt64())
    }

    static write(dataStream, callbackObj) {
        dataStream.writeInt64(this.lower(callbackObj))
    }

    static computeSize(callbackObj) {
        return 8;
    }
}
const uniffiCallbackHandlerTracingEventSink = new UniFFICallbackHandler(
    "EventSink",
    2,
    [
        new UniFFICallbackMethodHandler(
            "onEvent",
            [
                FfiConverterTypeTracingEvent,
            ],
            (result) => undefined,
            (e) => {
              throw e;
            }
        ),
    ]
);

// Allow the shutdown-related functionality to be tested in the unit tests
UnitTestObjs.uniffiCallbackHandlerTracingEventSink = uniffiCallbackHandlerTracingEventSink;


