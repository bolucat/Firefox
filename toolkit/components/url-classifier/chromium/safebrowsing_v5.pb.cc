// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: safebrowsing_v5.proto

#include "safebrowsing_v5.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace mozilla {
namespace safebrowsing {
namespace v5 {
PROTOBUF_CONSTEXPR SearchHashesRequest::SearchHashesRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hash_prefixes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SearchHashesRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SearchHashesRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SearchHashesRequestDefaultTypeInternal() {}
  union {
    SearchHashesRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SearchHashesRequestDefaultTypeInternal _SearchHashesRequest_default_instance_;
PROTOBUF_CONSTEXPR Duration::Duration(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.seconds_)*/int64_t{0}
  , /*decltype(_impl_.nanos_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DurationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DurationDefaultTypeInternal() {}
  union {
    Duration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DurationDefaultTypeInternal _Duration_default_instance_;
PROTOBUF_CONSTEXPR SearchHashesResponse::SearchHashesResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.full_hashes_)*/{}
  , /*decltype(_impl_.cache_duration_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SearchHashesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SearchHashesResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SearchHashesResponseDefaultTypeInternal() {}
  union {
    SearchHashesResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SearchHashesResponseDefaultTypeInternal _SearchHashesResponse_default_instance_;
PROTOBUF_CONSTEXPR FullHash_FullHashDetail::FullHash_FullHashDetail(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.attributes_)*/{}
  , /*decltype(_impl_._attributes_cached_byte_size_)*/{0}
  , /*decltype(_impl_.threat_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FullHash_FullHashDetailDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FullHash_FullHashDetailDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FullHash_FullHashDetailDefaultTypeInternal() {}
  union {
    FullHash_FullHashDetail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FullHash_FullHashDetailDefaultTypeInternal _FullHash_FullHashDetail_default_instance_;
PROTOBUF_CONSTEXPR FullHash::FullHash(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.full_hash_details_)*/{}
  , /*decltype(_impl_.full_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FullHashDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FullHashDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FullHashDefaultTypeInternal() {}
  union {
    FullHash _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FullHashDefaultTypeInternal _FullHash_default_instance_;
PROTOBUF_CONSTEXPR GetHashListRequest::GetHashListRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.size_constraints_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetHashListRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetHashListRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetHashListRequestDefaultTypeInternal() {}
  union {
    GetHashListRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetHashListRequestDefaultTypeInternal _GetHashListRequest_default_instance_;
PROTOBUF_CONSTEXPR SizeConstraints::SizeConstraints(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.max_update_entries_)*/0
  , /*decltype(_impl_.max_database_entries_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SizeConstraintsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SizeConstraintsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SizeConstraintsDefaultTypeInternal() {}
  union {
    SizeConstraints _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SizeConstraintsDefaultTypeInternal _SizeConstraints_default_instance_;
PROTOBUF_CONSTEXPR RiceDeltaEncoded32Bit::RiceDeltaEncoded32Bit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.encoded_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.first_value_)*/0u
  , /*decltype(_impl_.rice_parameter_)*/0
  , /*decltype(_impl_.entries_count_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RiceDeltaEncoded32BitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RiceDeltaEncoded32BitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RiceDeltaEncoded32BitDefaultTypeInternal() {}
  union {
    RiceDeltaEncoded32Bit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RiceDeltaEncoded32BitDefaultTypeInternal _RiceDeltaEncoded32Bit_default_instance_;
PROTOBUF_CONSTEXPR RiceDeltaEncoded64Bit::RiceDeltaEncoded64Bit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.encoded_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.first_value_)*/uint64_t{0u}
  , /*decltype(_impl_.rice_parameter_)*/0
  , /*decltype(_impl_.entries_count_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RiceDeltaEncoded64BitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RiceDeltaEncoded64BitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RiceDeltaEncoded64BitDefaultTypeInternal() {}
  union {
    RiceDeltaEncoded64Bit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RiceDeltaEncoded64BitDefaultTypeInternal _RiceDeltaEncoded64Bit_default_instance_;
PROTOBUF_CONSTEXPR RiceDeltaEncoded128Bit::RiceDeltaEncoded128Bit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.encoded_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.first_value_hi_)*/uint64_t{0u}
  , /*decltype(_impl_.first_value_lo_)*/uint64_t{0u}
  , /*decltype(_impl_.rice_parameter_)*/0
  , /*decltype(_impl_.entries_count_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RiceDeltaEncoded128BitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RiceDeltaEncoded128BitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RiceDeltaEncoded128BitDefaultTypeInternal() {}
  union {
    RiceDeltaEncoded128Bit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RiceDeltaEncoded128BitDefaultTypeInternal _RiceDeltaEncoded128Bit_default_instance_;
PROTOBUF_CONSTEXPR RiceDeltaEncoded256Bit::RiceDeltaEncoded256Bit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.encoded_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.first_value_first_part_)*/uint64_t{0u}
  , /*decltype(_impl_.first_value_second_part_)*/uint64_t{0u}
  , /*decltype(_impl_.first_value_third_part_)*/uint64_t{0u}
  , /*decltype(_impl_.first_value_fourth_part_)*/uint64_t{0u}
  , /*decltype(_impl_.rice_parameter_)*/0
  , /*decltype(_impl_.entries_count_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RiceDeltaEncoded256BitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RiceDeltaEncoded256BitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RiceDeltaEncoded256BitDefaultTypeInternal() {}
  union {
    RiceDeltaEncoded256Bit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RiceDeltaEncoded256BitDefaultTypeInternal _RiceDeltaEncoded256Bit_default_instance_;
PROTOBUF_CONSTEXPR HashListMetadata::HashListMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.threat_types_)*/{}
  , /*decltype(_impl_._threat_types_cached_byte_size_)*/{0}
  , /*decltype(_impl_.likely_safe_types_)*/{}
  , /*decltype(_impl_._likely_safe_types_cached_byte_size_)*/{0}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hash_length_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HashListMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HashListMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HashListMetadataDefaultTypeInternal() {}
  union {
    HashListMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HashListMetadataDefaultTypeInternal _HashListMetadata_default_instance_;
PROTOBUF_CONSTEXPR HashList::HashList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sha256_checksum_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.compressed_removals_)*/nullptr
  , /*decltype(_impl_.minimum_wait_duration_)*/nullptr
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.partial_update_)*/false
  , /*decltype(_impl_.compressed_additions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct HashListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HashListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HashListDefaultTypeInternal() {}
  union {
    HashList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HashListDefaultTypeInternal _HashList_default_instance_;
PROTOBUF_CONSTEXPR BatchGetHashListsRequest::BatchGetHashListsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.names_)*/{}
  , /*decltype(_impl_.version_)*/{}
  , /*decltype(_impl_.size_constraints_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchGetHashListsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchGetHashListsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchGetHashListsRequestDefaultTypeInternal() {}
  union {
    BatchGetHashListsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchGetHashListsRequestDefaultTypeInternal _BatchGetHashListsRequest_default_instance_;
PROTOBUF_CONSTEXPR BatchGetHashListsResponse::BatchGetHashListsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hash_lists_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchGetHashListsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchGetHashListsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchGetHashListsResponseDefaultTypeInternal() {}
  union {
    BatchGetHashListsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchGetHashListsResponseDefaultTypeInternal _BatchGetHashListsResponse_default_instance_;
PROTOBUF_CONSTEXPR ListHashListsRequest::ListHashListsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_size_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListHashListsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListHashListsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListHashListsRequestDefaultTypeInternal() {}
  union {
    ListHashListsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListHashListsRequestDefaultTypeInternal _ListHashListsRequest_default_instance_;
PROTOBUF_CONSTEXPR ListHashListsResponse::ListHashListsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hash_lists_)*/{}
  , /*decltype(_impl_.next_page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListHashListsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListHashListsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListHashListsResponseDefaultTypeInternal() {}
  union {
    ListHashListsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListHashListsResponseDefaultTypeInternal _ListHashListsResponse_default_instance_;
}  // namespace v5
}  // namespace safebrowsing
}  // namespace mozilla
namespace mozilla {
namespace safebrowsing {
namespace v5 {
bool HashListMetadata_HashLength_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> HashListMetadata_HashLength_strings[5] = {};

static const char HashListMetadata_HashLength_names[] =
  "EIGHT_BYTES"
  "FOUR_BYTES"
  "HASH_LENGTH_UNSPECIFIED"
  "SIXTEEN_BYTES"
  "THIRTY_TWO_BYTES";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry HashListMetadata_HashLength_entries[] = {
  { {HashListMetadata_HashLength_names + 0, 11}, 3 },
  { {HashListMetadata_HashLength_names + 11, 10}, 2 },
  { {HashListMetadata_HashLength_names + 21, 23}, 0 },
  { {HashListMetadata_HashLength_names + 44, 13}, 4 },
  { {HashListMetadata_HashLength_names + 57, 16}, 5 },
};

static const int HashListMetadata_HashLength_entries_by_number[] = {
  2, // 0 -> HASH_LENGTH_UNSPECIFIED
  1, // 2 -> FOUR_BYTES
  0, // 3 -> EIGHT_BYTES
  3, // 4 -> SIXTEEN_BYTES
  4, // 5 -> THIRTY_TWO_BYTES
};

const std::string& HashListMetadata_HashLength_Name(
    HashListMetadata_HashLength value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          HashListMetadata_HashLength_entries,
          HashListMetadata_HashLength_entries_by_number,
          5, HashListMetadata_HashLength_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      HashListMetadata_HashLength_entries,
      HashListMetadata_HashLength_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     HashListMetadata_HashLength_strings[idx].get();
}
bool HashListMetadata_HashLength_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HashListMetadata_HashLength* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      HashListMetadata_HashLength_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<HashListMetadata_HashLength>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr HashListMetadata_HashLength HashListMetadata::HASH_LENGTH_UNSPECIFIED;
constexpr HashListMetadata_HashLength HashListMetadata::FOUR_BYTES;
constexpr HashListMetadata_HashLength HashListMetadata::EIGHT_BYTES;
constexpr HashListMetadata_HashLength HashListMetadata::SIXTEEN_BYTES;
constexpr HashListMetadata_HashLength HashListMetadata::THIRTY_TWO_BYTES;
constexpr HashListMetadata_HashLength HashListMetadata::HashLength_MIN;
constexpr HashListMetadata_HashLength HashListMetadata::HashLength_MAX;
constexpr int HashListMetadata::HashLength_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ThreatType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ThreatType_strings[5] = {};

static const char ThreatType_names[] =
  "MALWARE"
  "POTENTIALLY_HARMFUL_APPLICATION"
  "SOCIAL_ENGINEERING"
  "THREAT_TYPE_UNSPECIFIED"
  "UNWANTED_SOFTWARE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ThreatType_entries[] = {
  { {ThreatType_names + 0, 7}, 1 },
  { {ThreatType_names + 7, 31}, 4 },
  { {ThreatType_names + 38, 18}, 2 },
  { {ThreatType_names + 56, 23}, 0 },
  { {ThreatType_names + 79, 17}, 3 },
};

static const int ThreatType_entries_by_number[] = {
  3, // 0 -> THREAT_TYPE_UNSPECIFIED
  0, // 1 -> MALWARE
  2, // 2 -> SOCIAL_ENGINEERING
  4, // 3 -> UNWANTED_SOFTWARE
  1, // 4 -> POTENTIALLY_HARMFUL_APPLICATION
};

const std::string& ThreatType_Name(
    ThreatType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ThreatType_entries,
          ThreatType_entries_by_number,
          5, ThreatType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ThreatType_entries,
      ThreatType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ThreatType_strings[idx].get();
}
bool ThreatType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThreatType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ThreatType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ThreatType>(int_value);
  }
  return success;
}
bool LikelySafeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LikelySafeType_strings[4] = {};

static const char LikelySafeType_names[] =
  "CSD"
  "DOWNLOAD"
  "GENERAL_BROWSING"
  "LIKELY_SAFE_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LikelySafeType_entries[] = {
  { {LikelySafeType_names + 0, 3}, 2 },
  { {LikelySafeType_names + 3, 8}, 3 },
  { {LikelySafeType_names + 11, 16}, 1 },
  { {LikelySafeType_names + 27, 28}, 0 },
};

static const int LikelySafeType_entries_by_number[] = {
  3, // 0 -> LIKELY_SAFE_TYPE_UNSPECIFIED
  2, // 1 -> GENERAL_BROWSING
  0, // 2 -> CSD
  1, // 3 -> DOWNLOAD
};

const std::string& LikelySafeType_Name(
    LikelySafeType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LikelySafeType_entries,
          LikelySafeType_entries_by_number,
          4, LikelySafeType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LikelySafeType_entries,
      LikelySafeType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LikelySafeType_strings[idx].get();
}
bool LikelySafeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LikelySafeType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LikelySafeType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<LikelySafeType>(int_value);
  }
  return success;
}
bool ThreatAttribute_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ThreatAttribute_strings[3] = {};

static const char ThreatAttribute_names[] =
  "CANARY"
  "FRAME_ONLY"
  "THREAT_ATTRIBUTE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ThreatAttribute_entries[] = {
  { {ThreatAttribute_names + 0, 6}, 1 },
  { {ThreatAttribute_names + 6, 10}, 2 },
  { {ThreatAttribute_names + 16, 28}, 0 },
};

static const int ThreatAttribute_entries_by_number[] = {
  2, // 0 -> THREAT_ATTRIBUTE_UNSPECIFIED
  0, // 1 -> CANARY
  1, // 2 -> FRAME_ONLY
};

const std::string& ThreatAttribute_Name(
    ThreatAttribute value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ThreatAttribute_entries,
          ThreatAttribute_entries_by_number,
          3, ThreatAttribute_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ThreatAttribute_entries,
      ThreatAttribute_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ThreatAttribute_strings[idx].get();
}
bool ThreatAttribute_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThreatAttribute* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ThreatAttribute_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ThreatAttribute>(int_value);
  }
  return success;
}

// ===================================================================

class SearchHashesRequest::_Internal {
 public:
};

SearchHashesRequest::SearchHashesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.v5.SearchHashesRequest)
}
SearchHashesRequest::SearchHashesRequest(const SearchHashesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SearchHashesRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hash_prefixes_){from._impl_.hash_prefixes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.v5.SearchHashesRequest)
}

inline void SearchHashesRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hash_prefixes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SearchHashesRequest::~SearchHashesRequest() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.v5.SearchHashesRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SearchHashesRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hash_prefixes_.~RepeatedPtrField();
}

void SearchHashesRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SearchHashesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.v5.SearchHashesRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hash_prefixes_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SearchHashesRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes hash_prefixes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_hash_prefixes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SearchHashesRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.v5.SearchHashesRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes hash_prefixes = 1;
  for (int i = 0, n = this->_internal_hash_prefixes_size(); i < n; i++) {
    const auto& s = this->_internal_hash_prefixes(i);
    target = stream->WriteBytes(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.v5.SearchHashesRequest)
  return target;
}

size_t SearchHashesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.v5.SearchHashesRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes hash_prefixes = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.hash_prefixes_.size());
  for (int i = 0, n = _impl_.hash_prefixes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.hash_prefixes_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SearchHashesRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SearchHashesRequest*>(
      &from));
}

void SearchHashesRequest::MergeFrom(const SearchHashesRequest& from) {
  SearchHashesRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.v5.SearchHashesRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.hash_prefixes_.MergeFrom(from._impl_.hash_prefixes_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SearchHashesRequest::CopyFrom(const SearchHashesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.v5.SearchHashesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SearchHashesRequest::IsInitialized() const {
  return true;
}

void SearchHashesRequest::InternalSwap(SearchHashesRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.hash_prefixes_.InternalSwap(&other->_impl_.hash_prefixes_);
}

std::string SearchHashesRequest::GetTypeName() const {
  return "mozilla.safebrowsing.v5.SearchHashesRequest";
}


// ===================================================================

class Duration::_Internal {
 public:
};

Duration::Duration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.v5.Duration)
}
Duration::Duration(const Duration& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Duration* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.seconds_){}
    , decltype(_impl_.nanos_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.seconds_, &from._impl_.seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nanos_) -
    reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanos_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.v5.Duration)
}

inline void Duration::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.seconds_){int64_t{0}}
    , decltype(_impl_.nanos_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Duration::~Duration() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.v5.Duration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Duration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Duration::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Duration::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.v5.Duration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.seconds_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.nanos_) -
      reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanos_));
  _internal_metadata_.Clear<std::string>();
}

const char* Duration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 seconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 nanos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.nanos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Duration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.v5.Duration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 seconds = 1;
  if (this->_internal_seconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seconds(), target);
  }

  // int32 nanos = 2;
  if (this->_internal_nanos() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_nanos(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.v5.Duration)
  return target;
}

size_t Duration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.v5.Duration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 seconds = 1;
  if (this->_internal_seconds() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seconds());
  }

  // int32 nanos = 2;
  if (this->_internal_nanos() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nanos());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Duration::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Duration*>(
      &from));
}

void Duration::MergeFrom(const Duration& from) {
  Duration* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.v5.Duration)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_seconds() != 0) {
    _this->_internal_set_seconds(from._internal_seconds());
  }
  if (from._internal_nanos() != 0) {
    _this->_internal_set_nanos(from._internal_nanos());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Duration::CopyFrom(const Duration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.v5.Duration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Duration::IsInitialized() const {
  return true;
}

void Duration::InternalSwap(Duration* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Duration, _impl_.nanos_)
      + sizeof(Duration::_impl_.nanos_)
      - PROTOBUF_FIELD_OFFSET(Duration, _impl_.seconds_)>(
          reinterpret_cast<char*>(&_impl_.seconds_),
          reinterpret_cast<char*>(&other->_impl_.seconds_));
}

std::string Duration::GetTypeName() const {
  return "mozilla.safebrowsing.v5.Duration";
}


// ===================================================================

class SearchHashesResponse::_Internal {
 public:
  static const ::mozilla::safebrowsing::v5::Duration& cache_duration(const SearchHashesResponse* msg);
};

const ::mozilla::safebrowsing::v5::Duration&
SearchHashesResponse::_Internal::cache_duration(const SearchHashesResponse* msg) {
  return *msg->_impl_.cache_duration_;
}
SearchHashesResponse::SearchHashesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.v5.SearchHashesResponse)
}
SearchHashesResponse::SearchHashesResponse(const SearchHashesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SearchHashesResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.full_hashes_){from._impl_.full_hashes_}
    , decltype(_impl_.cache_duration_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_cache_duration()) {
    _this->_impl_.cache_duration_ = new ::mozilla::safebrowsing::v5::Duration(*from._impl_.cache_duration_);
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.v5.SearchHashesResponse)
}

inline void SearchHashesResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.full_hashes_){arena}
    , decltype(_impl_.cache_duration_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SearchHashesResponse::~SearchHashesResponse() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.v5.SearchHashesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SearchHashesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.full_hashes_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.cache_duration_;
}

void SearchHashesResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SearchHashesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.v5.SearchHashesResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.full_hashes_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.cache_duration_ != nullptr) {
    delete _impl_.cache_duration_;
  }
  _impl_.cache_duration_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* SearchHashesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .mozilla.safebrowsing.v5.FullHash full_hashes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_full_hashes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .mozilla.safebrowsing.v5.Duration cache_duration = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cache_duration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SearchHashesResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.v5.SearchHashesResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.v5.FullHash full_hashes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_full_hashes_size()); i < n; i++) {
    const auto& repfield = this->_internal_full_hashes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .mozilla.safebrowsing.v5.Duration cache_duration = 2;
  if (this->_internal_has_cache_duration()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::cache_duration(this),
        _Internal::cache_duration(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.v5.SearchHashesResponse)
  return target;
}

size_t SearchHashesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.v5.SearchHashesResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.v5.FullHash full_hashes = 1;
  total_size += 1UL * this->_internal_full_hashes_size();
  for (const auto& msg : this->_impl_.full_hashes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .mozilla.safebrowsing.v5.Duration cache_duration = 2;
  if (this->_internal_has_cache_duration()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cache_duration_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SearchHashesResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SearchHashesResponse*>(
      &from));
}

void SearchHashesResponse::MergeFrom(const SearchHashesResponse& from) {
  SearchHashesResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.v5.SearchHashesResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.full_hashes_.MergeFrom(from._impl_.full_hashes_);
  if (from._internal_has_cache_duration()) {
    _this->_internal_mutable_cache_duration()->::mozilla::safebrowsing::v5::Duration::MergeFrom(
        from._internal_cache_duration());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SearchHashesResponse::CopyFrom(const SearchHashesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.v5.SearchHashesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SearchHashesResponse::IsInitialized() const {
  return true;
}

void SearchHashesResponse::InternalSwap(SearchHashesResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.full_hashes_.InternalSwap(&other->_impl_.full_hashes_);
  swap(_impl_.cache_duration_, other->_impl_.cache_duration_);
}

std::string SearchHashesResponse::GetTypeName() const {
  return "mozilla.safebrowsing.v5.SearchHashesResponse";
}


// ===================================================================

class FullHash_FullHashDetail::_Internal {
 public:
};

FullHash_FullHashDetail::FullHash_FullHashDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.v5.FullHash.FullHashDetail)
}
FullHash_FullHashDetail::FullHash_FullHashDetail(const FullHash_FullHashDetail& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FullHash_FullHashDetail* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.attributes_){from._impl_.attributes_}
    , /*decltype(_impl_._attributes_cached_byte_size_)*/{0}
    , decltype(_impl_.threat_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.threat_type_ = from._impl_.threat_type_;
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.v5.FullHash.FullHashDetail)
}

inline void FullHash_FullHashDetail::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.attributes_){arena}
    , /*decltype(_impl_._attributes_cached_byte_size_)*/{0}
    , decltype(_impl_.threat_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FullHash_FullHashDetail::~FullHash_FullHashDetail() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.v5.FullHash.FullHashDetail)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FullHash_FullHashDetail::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attributes_.~RepeatedField();
}

void FullHash_FullHashDetail::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FullHash_FullHashDetail::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.v5.FullHash.FullHashDetail)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.attributes_.Clear();
  _impl_.threat_type_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* FullHash_FullHashDetail::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .mozilla.safebrowsing.v5.ThreatType threat_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_threat_type(static_cast<::mozilla::safebrowsing::v5::ThreatType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.v5.ThreatAttribute attributes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_attributes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_attributes(static_cast<::mozilla::safebrowsing::v5::ThreatAttribute>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FullHash_FullHashDetail::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.v5.FullHash.FullHashDetail)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .mozilla.safebrowsing.v5.ThreatType threat_type = 1;
  if (this->_internal_threat_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_threat_type(), target);
  }

  // repeated .mozilla.safebrowsing.v5.ThreatAttribute attributes = 2;
  {
    int byte_size = _impl_._attributes_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          2, _impl_.attributes_, byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.v5.FullHash.FullHashDetail)
  return target;
}

size_t FullHash_FullHashDetail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.v5.FullHash.FullHashDetail)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.v5.ThreatAttribute attributes = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_attributes_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_attributes(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._attributes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .mozilla.safebrowsing.v5.ThreatType threat_type = 1;
  if (this->_internal_threat_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FullHash_FullHashDetail::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FullHash_FullHashDetail*>(
      &from));
}

void FullHash_FullHashDetail::MergeFrom(const FullHash_FullHashDetail& from) {
  FullHash_FullHashDetail* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.v5.FullHash.FullHashDetail)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.attributes_.MergeFrom(from._impl_.attributes_);
  if (from._internal_threat_type() != 0) {
    _this->_internal_set_threat_type(from._internal_threat_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FullHash_FullHashDetail::CopyFrom(const FullHash_FullHashDetail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.v5.FullHash.FullHashDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FullHash_FullHashDetail::IsInitialized() const {
  return true;
}

void FullHash_FullHashDetail::InternalSwap(FullHash_FullHashDetail* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.attributes_.InternalSwap(&other->_impl_.attributes_);
  swap(_impl_.threat_type_, other->_impl_.threat_type_);
}

std::string FullHash_FullHashDetail::GetTypeName() const {
  return "mozilla.safebrowsing.v5.FullHash.FullHashDetail";
}


// ===================================================================

class FullHash::_Internal {
 public:
};

FullHash::FullHash(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.v5.FullHash)
}
FullHash::FullHash(const FullHash& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FullHash* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.full_hash_details_){from._impl_.full_hash_details_}
    , decltype(_impl_.full_hash_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.full_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.full_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_full_hash().empty()) {
    _this->_impl_.full_hash_.Set(from._internal_full_hash(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.v5.FullHash)
}

inline void FullHash::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.full_hash_details_){arena}
    , decltype(_impl_.full_hash_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.full_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.full_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FullHash::~FullHash() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.v5.FullHash)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FullHash::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.full_hash_details_.~RepeatedPtrField();
  _impl_.full_hash_.Destroy();
}

void FullHash::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FullHash::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.v5.FullHash)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.full_hash_details_.Clear();
  _impl_.full_hash_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* FullHash::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes full_hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_full_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.v5.FullHash.FullHashDetail full_hash_details = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_full_hash_details(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FullHash::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.v5.FullHash)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes full_hash = 1;
  if (!this->_internal_full_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_full_hash(), target);
  }

  // repeated .mozilla.safebrowsing.v5.FullHash.FullHashDetail full_hash_details = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_full_hash_details_size()); i < n; i++) {
    const auto& repfield = this->_internal_full_hash_details(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.v5.FullHash)
  return target;
}

size_t FullHash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.v5.FullHash)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.v5.FullHash.FullHashDetail full_hash_details = 2;
  total_size += 1UL * this->_internal_full_hash_details_size();
  for (const auto& msg : this->_impl_.full_hash_details_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bytes full_hash = 1;
  if (!this->_internal_full_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_full_hash());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FullHash::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FullHash*>(
      &from));
}

void FullHash::MergeFrom(const FullHash& from) {
  FullHash* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.v5.FullHash)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.full_hash_details_.MergeFrom(from._impl_.full_hash_details_);
  if (!from._internal_full_hash().empty()) {
    _this->_internal_set_full_hash(from._internal_full_hash());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FullHash::CopyFrom(const FullHash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.v5.FullHash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FullHash::IsInitialized() const {
  return true;
}

void FullHash::InternalSwap(FullHash* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.full_hash_details_.InternalSwap(&other->_impl_.full_hash_details_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.full_hash_, lhs_arena,
      &other->_impl_.full_hash_, rhs_arena
  );
}

std::string FullHash::GetTypeName() const {
  return "mozilla.safebrowsing.v5.FullHash";
}


// ===================================================================

class GetHashListRequest::_Internal {
 public:
  static const ::mozilla::safebrowsing::v5::SizeConstraints& size_constraints(const GetHashListRequest* msg);
};

const ::mozilla::safebrowsing::v5::SizeConstraints&
GetHashListRequest::_Internal::size_constraints(const GetHashListRequest* msg) {
  return *msg->_impl_.size_constraints_;
}
GetHashListRequest::GetHashListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.v5.GetHashListRequest)
}
GetHashListRequest::GetHashListRequest(const GetHashListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GetHashListRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.size_constraints_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_version().empty()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_size_constraints()) {
    _this->_impl_.size_constraints_ = new ::mozilla::safebrowsing::v5::SizeConstraints(*from._impl_.size_constraints_);
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.v5.GetHashListRequest)
}

inline void GetHashListRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.size_constraints_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetHashListRequest::~GetHashListRequest() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.v5.GetHashListRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetHashListRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.version_.Destroy();
  if (this != internal_default_instance()) delete _impl_.size_constraints_;
}

void GetHashListRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetHashListRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.v5.GetHashListRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.version_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.size_constraints_ != nullptr) {
    delete _impl_.size_constraints_;
  }
  _impl_.size_constraints_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* GetHashListRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // bytes version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .mozilla.safebrowsing.v5.SizeConstraints size_constraints = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_size_constraints(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetHashListRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.v5.GetHashListRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "mozilla.safebrowsing.v5.GetHashListRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bytes version = 2;
  if (!this->_internal_version().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_version(), target);
  }

  // .mozilla.safebrowsing.v5.SizeConstraints size_constraints = 4;
  if (this->_internal_has_size_constraints()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::size_constraints(this),
        _Internal::size_constraints(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.v5.GetHashListRequest)
  return target;
}

size_t GetHashListRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.v5.GetHashListRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bytes version = 2;
  if (!this->_internal_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_version());
  }

  // .mozilla.safebrowsing.v5.SizeConstraints size_constraints = 4;
  if (this->_internal_has_size_constraints()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.size_constraints_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetHashListRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetHashListRequest*>(
      &from));
}

void GetHashListRequest::MergeFrom(const GetHashListRequest& from) {
  GetHashListRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.v5.GetHashListRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_version().empty()) {
    _this->_internal_set_version(from._internal_version());
  }
  if (from._internal_has_size_constraints()) {
    _this->_internal_mutable_size_constraints()->::mozilla::safebrowsing::v5::SizeConstraints::MergeFrom(
        from._internal_size_constraints());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetHashListRequest::CopyFrom(const GetHashListRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.v5.GetHashListRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetHashListRequest::IsInitialized() const {
  return true;
}

void GetHashListRequest::InternalSwap(GetHashListRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  swap(_impl_.size_constraints_, other->_impl_.size_constraints_);
}

std::string GetHashListRequest::GetTypeName() const {
  return "mozilla.safebrowsing.v5.GetHashListRequest";
}


// ===================================================================

class SizeConstraints::_Internal {
 public:
};

SizeConstraints::SizeConstraints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.v5.SizeConstraints)
}
SizeConstraints::SizeConstraints(const SizeConstraints& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SizeConstraints* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.max_update_entries_){}
    , decltype(_impl_.max_database_entries_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.max_update_entries_, &from._impl_.max_update_entries_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_database_entries_) -
    reinterpret_cast<char*>(&_impl_.max_update_entries_)) + sizeof(_impl_.max_database_entries_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.v5.SizeConstraints)
}

inline void SizeConstraints::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.max_update_entries_){0}
    , decltype(_impl_.max_database_entries_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SizeConstraints::~SizeConstraints() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.v5.SizeConstraints)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SizeConstraints::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SizeConstraints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SizeConstraints::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.v5.SizeConstraints)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.max_update_entries_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.max_database_entries_) -
      reinterpret_cast<char*>(&_impl_.max_update_entries_)) + sizeof(_impl_.max_database_entries_));
  _internal_metadata_.Clear<std::string>();
}

const char* SizeConstraints::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 max_update_entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.max_update_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_database_entries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.max_database_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SizeConstraints::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.v5.SizeConstraints)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 max_update_entries = 1;
  if (this->_internal_max_update_entries() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_max_update_entries(), target);
  }

  // int32 max_database_entries = 2;
  if (this->_internal_max_database_entries() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_max_database_entries(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.v5.SizeConstraints)
  return target;
}

size_t SizeConstraints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.v5.SizeConstraints)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 max_update_entries = 1;
  if (this->_internal_max_update_entries() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_update_entries());
  }

  // int32 max_database_entries = 2;
  if (this->_internal_max_database_entries() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_database_entries());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SizeConstraints::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SizeConstraints*>(
      &from));
}

void SizeConstraints::MergeFrom(const SizeConstraints& from) {
  SizeConstraints* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.v5.SizeConstraints)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_max_update_entries() != 0) {
    _this->_internal_set_max_update_entries(from._internal_max_update_entries());
  }
  if (from._internal_max_database_entries() != 0) {
    _this->_internal_set_max_database_entries(from._internal_max_database_entries());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SizeConstraints::CopyFrom(const SizeConstraints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.v5.SizeConstraints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SizeConstraints::IsInitialized() const {
  return true;
}

void SizeConstraints::InternalSwap(SizeConstraints* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SizeConstraints, _impl_.max_database_entries_)
      + sizeof(SizeConstraints::_impl_.max_database_entries_)
      - PROTOBUF_FIELD_OFFSET(SizeConstraints, _impl_.max_update_entries_)>(
          reinterpret_cast<char*>(&_impl_.max_update_entries_),
          reinterpret_cast<char*>(&other->_impl_.max_update_entries_));
}

std::string SizeConstraints::GetTypeName() const {
  return "mozilla.safebrowsing.v5.SizeConstraints";
}


// ===================================================================

class RiceDeltaEncoded32Bit::_Internal {
 public:
};

RiceDeltaEncoded32Bit::RiceDeltaEncoded32Bit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.v5.RiceDeltaEncoded32Bit)
}
RiceDeltaEncoded32Bit::RiceDeltaEncoded32Bit(const RiceDeltaEncoded32Bit& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RiceDeltaEncoded32Bit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.encoded_data_){}
    , decltype(_impl_.first_value_){}
    , decltype(_impl_.rice_parameter_){}
    , decltype(_impl_.entries_count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.encoded_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encoded_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_encoded_data().empty()) {
    _this->_impl_.encoded_data_.Set(from._internal_encoded_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.first_value_, &from._impl_.first_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.entries_count_) -
    reinterpret_cast<char*>(&_impl_.first_value_)) + sizeof(_impl_.entries_count_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.v5.RiceDeltaEncoded32Bit)
}

inline void RiceDeltaEncoded32Bit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.encoded_data_){}
    , decltype(_impl_.first_value_){0u}
    , decltype(_impl_.rice_parameter_){0}
    , decltype(_impl_.entries_count_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.encoded_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encoded_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RiceDeltaEncoded32Bit::~RiceDeltaEncoded32Bit() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.v5.RiceDeltaEncoded32Bit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RiceDeltaEncoded32Bit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.encoded_data_.Destroy();
}

void RiceDeltaEncoded32Bit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RiceDeltaEncoded32Bit::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.v5.RiceDeltaEncoded32Bit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.encoded_data_.ClearToEmpty();
  ::memset(&_impl_.first_value_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.entries_count_) -
      reinterpret_cast<char*>(&_impl_.first_value_)) + sizeof(_impl_.entries_count_));
  _internal_metadata_.Clear<std::string>();
}

const char* RiceDeltaEncoded32Bit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 first_value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.first_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 rice_parameter = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.rice_parameter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 entries_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.entries_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes encoded_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_encoded_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RiceDeltaEncoded32Bit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.v5.RiceDeltaEncoded32Bit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 first_value = 1;
  if (this->_internal_first_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_first_value(), target);
  }

  // int32 rice_parameter = 2;
  if (this->_internal_rice_parameter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_rice_parameter(), target);
  }

  // int32 entries_count = 3;
  if (this->_internal_entries_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_entries_count(), target);
  }

  // bytes encoded_data = 4;
  if (!this->_internal_encoded_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_encoded_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.v5.RiceDeltaEncoded32Bit)
  return target;
}

size_t RiceDeltaEncoded32Bit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.v5.RiceDeltaEncoded32Bit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes encoded_data = 4;
  if (!this->_internal_encoded_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encoded_data());
  }

  // uint32 first_value = 1;
  if (this->_internal_first_value() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_first_value());
  }

  // int32 rice_parameter = 2;
  if (this->_internal_rice_parameter() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rice_parameter());
  }

  // int32 entries_count = 3;
  if (this->_internal_entries_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_entries_count());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RiceDeltaEncoded32Bit::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RiceDeltaEncoded32Bit*>(
      &from));
}

void RiceDeltaEncoded32Bit::MergeFrom(const RiceDeltaEncoded32Bit& from) {
  RiceDeltaEncoded32Bit* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.v5.RiceDeltaEncoded32Bit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_encoded_data().empty()) {
    _this->_internal_set_encoded_data(from._internal_encoded_data());
  }
  if (from._internal_first_value() != 0) {
    _this->_internal_set_first_value(from._internal_first_value());
  }
  if (from._internal_rice_parameter() != 0) {
    _this->_internal_set_rice_parameter(from._internal_rice_parameter());
  }
  if (from._internal_entries_count() != 0) {
    _this->_internal_set_entries_count(from._internal_entries_count());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RiceDeltaEncoded32Bit::CopyFrom(const RiceDeltaEncoded32Bit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.v5.RiceDeltaEncoded32Bit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RiceDeltaEncoded32Bit::IsInitialized() const {
  return true;
}

void RiceDeltaEncoded32Bit::InternalSwap(RiceDeltaEncoded32Bit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.encoded_data_, lhs_arena,
      &other->_impl_.encoded_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RiceDeltaEncoded32Bit, _impl_.entries_count_)
      + sizeof(RiceDeltaEncoded32Bit::_impl_.entries_count_)
      - PROTOBUF_FIELD_OFFSET(RiceDeltaEncoded32Bit, _impl_.first_value_)>(
          reinterpret_cast<char*>(&_impl_.first_value_),
          reinterpret_cast<char*>(&other->_impl_.first_value_));
}

std::string RiceDeltaEncoded32Bit::GetTypeName() const {
  return "mozilla.safebrowsing.v5.RiceDeltaEncoded32Bit";
}


// ===================================================================

class RiceDeltaEncoded64Bit::_Internal {
 public:
};

RiceDeltaEncoded64Bit::RiceDeltaEncoded64Bit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.v5.RiceDeltaEncoded64Bit)
}
RiceDeltaEncoded64Bit::RiceDeltaEncoded64Bit(const RiceDeltaEncoded64Bit& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RiceDeltaEncoded64Bit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.encoded_data_){}
    , decltype(_impl_.first_value_){}
    , decltype(_impl_.rice_parameter_){}
    , decltype(_impl_.entries_count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.encoded_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encoded_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_encoded_data().empty()) {
    _this->_impl_.encoded_data_.Set(from._internal_encoded_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.first_value_, &from._impl_.first_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.entries_count_) -
    reinterpret_cast<char*>(&_impl_.first_value_)) + sizeof(_impl_.entries_count_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.v5.RiceDeltaEncoded64Bit)
}

inline void RiceDeltaEncoded64Bit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.encoded_data_){}
    , decltype(_impl_.first_value_){uint64_t{0u}}
    , decltype(_impl_.rice_parameter_){0}
    , decltype(_impl_.entries_count_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.encoded_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encoded_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RiceDeltaEncoded64Bit::~RiceDeltaEncoded64Bit() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.v5.RiceDeltaEncoded64Bit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RiceDeltaEncoded64Bit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.encoded_data_.Destroy();
}

void RiceDeltaEncoded64Bit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RiceDeltaEncoded64Bit::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.v5.RiceDeltaEncoded64Bit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.encoded_data_.ClearToEmpty();
  ::memset(&_impl_.first_value_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.entries_count_) -
      reinterpret_cast<char*>(&_impl_.first_value_)) + sizeof(_impl_.entries_count_));
  _internal_metadata_.Clear<std::string>();
}

const char* RiceDeltaEncoded64Bit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 first_value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.first_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 rice_parameter = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.rice_parameter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 entries_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.entries_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes encoded_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_encoded_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RiceDeltaEncoded64Bit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.v5.RiceDeltaEncoded64Bit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 first_value = 1;
  if (this->_internal_first_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_first_value(), target);
  }

  // int32 rice_parameter = 2;
  if (this->_internal_rice_parameter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_rice_parameter(), target);
  }

  // int32 entries_count = 3;
  if (this->_internal_entries_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_entries_count(), target);
  }

  // bytes encoded_data = 4;
  if (!this->_internal_encoded_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_encoded_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.v5.RiceDeltaEncoded64Bit)
  return target;
}

size_t RiceDeltaEncoded64Bit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.v5.RiceDeltaEncoded64Bit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes encoded_data = 4;
  if (!this->_internal_encoded_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encoded_data());
  }

  // uint64 first_value = 1;
  if (this->_internal_first_value() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_first_value());
  }

  // int32 rice_parameter = 2;
  if (this->_internal_rice_parameter() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rice_parameter());
  }

  // int32 entries_count = 3;
  if (this->_internal_entries_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_entries_count());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RiceDeltaEncoded64Bit::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RiceDeltaEncoded64Bit*>(
      &from));
}

void RiceDeltaEncoded64Bit::MergeFrom(const RiceDeltaEncoded64Bit& from) {
  RiceDeltaEncoded64Bit* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.v5.RiceDeltaEncoded64Bit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_encoded_data().empty()) {
    _this->_internal_set_encoded_data(from._internal_encoded_data());
  }
  if (from._internal_first_value() != 0) {
    _this->_internal_set_first_value(from._internal_first_value());
  }
  if (from._internal_rice_parameter() != 0) {
    _this->_internal_set_rice_parameter(from._internal_rice_parameter());
  }
  if (from._internal_entries_count() != 0) {
    _this->_internal_set_entries_count(from._internal_entries_count());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RiceDeltaEncoded64Bit::CopyFrom(const RiceDeltaEncoded64Bit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.v5.RiceDeltaEncoded64Bit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RiceDeltaEncoded64Bit::IsInitialized() const {
  return true;
}

void RiceDeltaEncoded64Bit::InternalSwap(RiceDeltaEncoded64Bit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.encoded_data_, lhs_arena,
      &other->_impl_.encoded_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RiceDeltaEncoded64Bit, _impl_.entries_count_)
      + sizeof(RiceDeltaEncoded64Bit::_impl_.entries_count_)
      - PROTOBUF_FIELD_OFFSET(RiceDeltaEncoded64Bit, _impl_.first_value_)>(
          reinterpret_cast<char*>(&_impl_.first_value_),
          reinterpret_cast<char*>(&other->_impl_.first_value_));
}

std::string RiceDeltaEncoded64Bit::GetTypeName() const {
  return "mozilla.safebrowsing.v5.RiceDeltaEncoded64Bit";
}


// ===================================================================

class RiceDeltaEncoded128Bit::_Internal {
 public:
};

RiceDeltaEncoded128Bit::RiceDeltaEncoded128Bit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.v5.RiceDeltaEncoded128Bit)
}
RiceDeltaEncoded128Bit::RiceDeltaEncoded128Bit(const RiceDeltaEncoded128Bit& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RiceDeltaEncoded128Bit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.encoded_data_){}
    , decltype(_impl_.first_value_hi_){}
    , decltype(_impl_.first_value_lo_){}
    , decltype(_impl_.rice_parameter_){}
    , decltype(_impl_.entries_count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.encoded_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encoded_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_encoded_data().empty()) {
    _this->_impl_.encoded_data_.Set(from._internal_encoded_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.first_value_hi_, &from._impl_.first_value_hi_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.entries_count_) -
    reinterpret_cast<char*>(&_impl_.first_value_hi_)) + sizeof(_impl_.entries_count_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.v5.RiceDeltaEncoded128Bit)
}

inline void RiceDeltaEncoded128Bit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.encoded_data_){}
    , decltype(_impl_.first_value_hi_){uint64_t{0u}}
    , decltype(_impl_.first_value_lo_){uint64_t{0u}}
    , decltype(_impl_.rice_parameter_){0}
    , decltype(_impl_.entries_count_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.encoded_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encoded_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RiceDeltaEncoded128Bit::~RiceDeltaEncoded128Bit() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.v5.RiceDeltaEncoded128Bit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RiceDeltaEncoded128Bit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.encoded_data_.Destroy();
}

void RiceDeltaEncoded128Bit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RiceDeltaEncoded128Bit::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.v5.RiceDeltaEncoded128Bit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.encoded_data_.ClearToEmpty();
  ::memset(&_impl_.first_value_hi_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.entries_count_) -
      reinterpret_cast<char*>(&_impl_.first_value_hi_)) + sizeof(_impl_.entries_count_));
  _internal_metadata_.Clear<std::string>();
}

const char* RiceDeltaEncoded128Bit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 first_value_hi = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.first_value_hi_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // fixed64 first_value_lo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.first_value_lo_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // int32 rice_parameter = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.rice_parameter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 entries_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.entries_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes encoded_data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_encoded_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RiceDeltaEncoded128Bit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.v5.RiceDeltaEncoded128Bit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 first_value_hi = 1;
  if (this->_internal_first_value_hi() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_first_value_hi(), target);
  }

  // fixed64 first_value_lo = 2;
  if (this->_internal_first_value_lo() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_first_value_lo(), target);
  }

  // int32 rice_parameter = 3;
  if (this->_internal_rice_parameter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_rice_parameter(), target);
  }

  // int32 entries_count = 4;
  if (this->_internal_entries_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_entries_count(), target);
  }

  // bytes encoded_data = 5;
  if (!this->_internal_encoded_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_encoded_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.v5.RiceDeltaEncoded128Bit)
  return target;
}

size_t RiceDeltaEncoded128Bit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.v5.RiceDeltaEncoded128Bit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes encoded_data = 5;
  if (!this->_internal_encoded_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encoded_data());
  }

  // uint64 first_value_hi = 1;
  if (this->_internal_first_value_hi() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_first_value_hi());
  }

  // fixed64 first_value_lo = 2;
  if (this->_internal_first_value_lo() != 0) {
    total_size += 1 + 8;
  }

  // int32 rice_parameter = 3;
  if (this->_internal_rice_parameter() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rice_parameter());
  }

  // int32 entries_count = 4;
  if (this->_internal_entries_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_entries_count());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RiceDeltaEncoded128Bit::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RiceDeltaEncoded128Bit*>(
      &from));
}

void RiceDeltaEncoded128Bit::MergeFrom(const RiceDeltaEncoded128Bit& from) {
  RiceDeltaEncoded128Bit* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.v5.RiceDeltaEncoded128Bit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_encoded_data().empty()) {
    _this->_internal_set_encoded_data(from._internal_encoded_data());
  }
  if (from._internal_first_value_hi() != 0) {
    _this->_internal_set_first_value_hi(from._internal_first_value_hi());
  }
  if (from._internal_first_value_lo() != 0) {
    _this->_internal_set_first_value_lo(from._internal_first_value_lo());
  }
  if (from._internal_rice_parameter() != 0) {
    _this->_internal_set_rice_parameter(from._internal_rice_parameter());
  }
  if (from._internal_entries_count() != 0) {
    _this->_internal_set_entries_count(from._internal_entries_count());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RiceDeltaEncoded128Bit::CopyFrom(const RiceDeltaEncoded128Bit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.v5.RiceDeltaEncoded128Bit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RiceDeltaEncoded128Bit::IsInitialized() const {
  return true;
}

void RiceDeltaEncoded128Bit::InternalSwap(RiceDeltaEncoded128Bit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.encoded_data_, lhs_arena,
      &other->_impl_.encoded_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RiceDeltaEncoded128Bit, _impl_.entries_count_)
      + sizeof(RiceDeltaEncoded128Bit::_impl_.entries_count_)
      - PROTOBUF_FIELD_OFFSET(RiceDeltaEncoded128Bit, _impl_.first_value_hi_)>(
          reinterpret_cast<char*>(&_impl_.first_value_hi_),
          reinterpret_cast<char*>(&other->_impl_.first_value_hi_));
}

std::string RiceDeltaEncoded128Bit::GetTypeName() const {
  return "mozilla.safebrowsing.v5.RiceDeltaEncoded128Bit";
}


// ===================================================================

class RiceDeltaEncoded256Bit::_Internal {
 public:
};

RiceDeltaEncoded256Bit::RiceDeltaEncoded256Bit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.v5.RiceDeltaEncoded256Bit)
}
RiceDeltaEncoded256Bit::RiceDeltaEncoded256Bit(const RiceDeltaEncoded256Bit& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RiceDeltaEncoded256Bit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.encoded_data_){}
    , decltype(_impl_.first_value_first_part_){}
    , decltype(_impl_.first_value_second_part_){}
    , decltype(_impl_.first_value_third_part_){}
    , decltype(_impl_.first_value_fourth_part_){}
    , decltype(_impl_.rice_parameter_){}
    , decltype(_impl_.entries_count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.encoded_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encoded_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_encoded_data().empty()) {
    _this->_impl_.encoded_data_.Set(from._internal_encoded_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.first_value_first_part_, &from._impl_.first_value_first_part_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.entries_count_) -
    reinterpret_cast<char*>(&_impl_.first_value_first_part_)) + sizeof(_impl_.entries_count_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.v5.RiceDeltaEncoded256Bit)
}

inline void RiceDeltaEncoded256Bit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.encoded_data_){}
    , decltype(_impl_.first_value_first_part_){uint64_t{0u}}
    , decltype(_impl_.first_value_second_part_){uint64_t{0u}}
    , decltype(_impl_.first_value_third_part_){uint64_t{0u}}
    , decltype(_impl_.first_value_fourth_part_){uint64_t{0u}}
    , decltype(_impl_.rice_parameter_){0}
    , decltype(_impl_.entries_count_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.encoded_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encoded_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RiceDeltaEncoded256Bit::~RiceDeltaEncoded256Bit() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.v5.RiceDeltaEncoded256Bit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RiceDeltaEncoded256Bit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.encoded_data_.Destroy();
}

void RiceDeltaEncoded256Bit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RiceDeltaEncoded256Bit::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.v5.RiceDeltaEncoded256Bit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.encoded_data_.ClearToEmpty();
  ::memset(&_impl_.first_value_first_part_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.entries_count_) -
      reinterpret_cast<char*>(&_impl_.first_value_first_part_)) + sizeof(_impl_.entries_count_));
  _internal_metadata_.Clear<std::string>();
}

const char* RiceDeltaEncoded256Bit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 first_value_first_part = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.first_value_first_part_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // fixed64 first_value_second_part = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.first_value_second_part_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // fixed64 first_value_third_part = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.first_value_third_part_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // fixed64 first_value_fourth_part = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.first_value_fourth_part_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // int32 rice_parameter = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.rice_parameter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 entries_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.entries_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes encoded_data = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_encoded_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RiceDeltaEncoded256Bit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.v5.RiceDeltaEncoded256Bit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 first_value_first_part = 1;
  if (this->_internal_first_value_first_part() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_first_value_first_part(), target);
  }

  // fixed64 first_value_second_part = 2;
  if (this->_internal_first_value_second_part() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_first_value_second_part(), target);
  }

  // fixed64 first_value_third_part = 3;
  if (this->_internal_first_value_third_part() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_first_value_third_part(), target);
  }

  // fixed64 first_value_fourth_part = 4;
  if (this->_internal_first_value_fourth_part() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(4, this->_internal_first_value_fourth_part(), target);
  }

  // int32 rice_parameter = 5;
  if (this->_internal_rice_parameter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_rice_parameter(), target);
  }

  // int32 entries_count = 6;
  if (this->_internal_entries_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_entries_count(), target);
  }

  // bytes encoded_data = 7;
  if (!this->_internal_encoded_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_encoded_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.v5.RiceDeltaEncoded256Bit)
  return target;
}

size_t RiceDeltaEncoded256Bit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.v5.RiceDeltaEncoded256Bit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes encoded_data = 7;
  if (!this->_internal_encoded_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encoded_data());
  }

  // uint64 first_value_first_part = 1;
  if (this->_internal_first_value_first_part() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_first_value_first_part());
  }

  // fixed64 first_value_second_part = 2;
  if (this->_internal_first_value_second_part() != 0) {
    total_size += 1 + 8;
  }

  // fixed64 first_value_third_part = 3;
  if (this->_internal_first_value_third_part() != 0) {
    total_size += 1 + 8;
  }

  // fixed64 first_value_fourth_part = 4;
  if (this->_internal_first_value_fourth_part() != 0) {
    total_size += 1 + 8;
  }

  // int32 rice_parameter = 5;
  if (this->_internal_rice_parameter() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rice_parameter());
  }

  // int32 entries_count = 6;
  if (this->_internal_entries_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_entries_count());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RiceDeltaEncoded256Bit::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RiceDeltaEncoded256Bit*>(
      &from));
}

void RiceDeltaEncoded256Bit::MergeFrom(const RiceDeltaEncoded256Bit& from) {
  RiceDeltaEncoded256Bit* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.v5.RiceDeltaEncoded256Bit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_encoded_data().empty()) {
    _this->_internal_set_encoded_data(from._internal_encoded_data());
  }
  if (from._internal_first_value_first_part() != 0) {
    _this->_internal_set_first_value_first_part(from._internal_first_value_first_part());
  }
  if (from._internal_first_value_second_part() != 0) {
    _this->_internal_set_first_value_second_part(from._internal_first_value_second_part());
  }
  if (from._internal_first_value_third_part() != 0) {
    _this->_internal_set_first_value_third_part(from._internal_first_value_third_part());
  }
  if (from._internal_first_value_fourth_part() != 0) {
    _this->_internal_set_first_value_fourth_part(from._internal_first_value_fourth_part());
  }
  if (from._internal_rice_parameter() != 0) {
    _this->_internal_set_rice_parameter(from._internal_rice_parameter());
  }
  if (from._internal_entries_count() != 0) {
    _this->_internal_set_entries_count(from._internal_entries_count());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RiceDeltaEncoded256Bit::CopyFrom(const RiceDeltaEncoded256Bit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.v5.RiceDeltaEncoded256Bit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RiceDeltaEncoded256Bit::IsInitialized() const {
  return true;
}

void RiceDeltaEncoded256Bit::InternalSwap(RiceDeltaEncoded256Bit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.encoded_data_, lhs_arena,
      &other->_impl_.encoded_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RiceDeltaEncoded256Bit, _impl_.entries_count_)
      + sizeof(RiceDeltaEncoded256Bit::_impl_.entries_count_)
      - PROTOBUF_FIELD_OFFSET(RiceDeltaEncoded256Bit, _impl_.first_value_first_part_)>(
          reinterpret_cast<char*>(&_impl_.first_value_first_part_),
          reinterpret_cast<char*>(&other->_impl_.first_value_first_part_));
}

std::string RiceDeltaEncoded256Bit::GetTypeName() const {
  return "mozilla.safebrowsing.v5.RiceDeltaEncoded256Bit";
}


// ===================================================================

class HashListMetadata::_Internal {
 public:
};

HashListMetadata::HashListMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.v5.HashListMetadata)
}
HashListMetadata::HashListMetadata(const HashListMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  HashListMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.threat_types_){from._impl_.threat_types_}
    , /*decltype(_impl_._threat_types_cached_byte_size_)*/{0}
    , decltype(_impl_.likely_safe_types_){from._impl_.likely_safe_types_}
    , /*decltype(_impl_._likely_safe_types_cached_byte_size_)*/{0}
    , decltype(_impl_.description_){}
    , decltype(_impl_.hash_length_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.hash_length_ = from._impl_.hash_length_;
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.v5.HashListMetadata)
}

inline void HashListMetadata::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.threat_types_){arena}
    , /*decltype(_impl_._threat_types_cached_byte_size_)*/{0}
    , decltype(_impl_.likely_safe_types_){arena}
    , /*decltype(_impl_._likely_safe_types_cached_byte_size_)*/{0}
    , decltype(_impl_.description_){}
    , decltype(_impl_.hash_length_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HashListMetadata::~HashListMetadata() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.v5.HashListMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HashListMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.threat_types_.~RepeatedField();
  _impl_.likely_safe_types_.~RepeatedField();
  _impl_.description_.Destroy();
}

void HashListMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HashListMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.v5.HashListMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.threat_types_.Clear();
  _impl_.likely_safe_types_.Clear();
  _impl_.description_.ClearToEmpty();
  _impl_.hash_length_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* HashListMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .mozilla.safebrowsing.v5.ThreatType threat_types = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_threat_types(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_threat_types(static_cast<::mozilla::safebrowsing::v5::ThreatType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.v5.LikelySafeType likely_safe_types = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_likely_safe_types(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_likely_safe_types(static_cast<::mozilla::safebrowsing::v5::LikelySafeType>(val));
        } else
          goto handle_unusual;
        continue;
      // string description = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .mozilla.safebrowsing.v5.HashListMetadata.HashLength hash_length = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_hash_length(static_cast<::mozilla::safebrowsing::v5::HashListMetadata_HashLength>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HashListMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.v5.HashListMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.v5.ThreatType threat_types = 1;
  {
    int byte_size = _impl_._threat_types_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          1, _impl_.threat_types_, byte_size, target);
    }
  }

  // repeated .mozilla.safebrowsing.v5.LikelySafeType likely_safe_types = 2;
  {
    int byte_size = _impl_._likely_safe_types_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          2, _impl_.likely_safe_types_, byte_size, target);
    }
  }

  // string description = 4;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "mozilla.safebrowsing.v5.HashListMetadata.description");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_description(), target);
  }

  // .mozilla.safebrowsing.v5.HashListMetadata.HashLength hash_length = 6;
  if (this->_internal_hash_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_hash_length(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.v5.HashListMetadata)
  return target;
}

size_t HashListMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.v5.HashListMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.v5.ThreatType threat_types = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_threat_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_threat_types(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._threat_types_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .mozilla.safebrowsing.v5.LikelySafeType likely_safe_types = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_likely_safe_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_likely_safe_types(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._likely_safe_types_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string description = 4;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // .mozilla.safebrowsing.v5.HashListMetadata.HashLength hash_length = 6;
  if (this->_internal_hash_length() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_hash_length());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HashListMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const HashListMetadata*>(
      &from));
}

void HashListMetadata::MergeFrom(const HashListMetadata& from) {
  HashListMetadata* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.v5.HashListMetadata)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.threat_types_.MergeFrom(from._impl_.threat_types_);
  _this->_impl_.likely_safe_types_.MergeFrom(from._impl_.likely_safe_types_);
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (from._internal_hash_length() != 0) {
    _this->_internal_set_hash_length(from._internal_hash_length());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HashListMetadata::CopyFrom(const HashListMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.v5.HashListMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HashListMetadata::IsInitialized() const {
  return true;
}

void HashListMetadata::InternalSwap(HashListMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.threat_types_.InternalSwap(&other->_impl_.threat_types_);
  _impl_.likely_safe_types_.InternalSwap(&other->_impl_.likely_safe_types_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  swap(_impl_.hash_length_, other->_impl_.hash_length_);
}

std::string HashListMetadata::GetTypeName() const {
  return "mozilla.safebrowsing.v5.HashListMetadata";
}


// ===================================================================

class HashList::_Internal {
 public:
  static const ::mozilla::safebrowsing::v5::RiceDeltaEncoded32Bit& additions_four_bytes(const HashList* msg);
  static const ::mozilla::safebrowsing::v5::RiceDeltaEncoded64Bit& additions_eight_bytes(const HashList* msg);
  static const ::mozilla::safebrowsing::v5::RiceDeltaEncoded128Bit& additions_sixteen_bytes(const HashList* msg);
  static const ::mozilla::safebrowsing::v5::RiceDeltaEncoded256Bit& additions_thirty_two_bytes(const HashList* msg);
  static const ::mozilla::safebrowsing::v5::RiceDeltaEncoded32Bit& compressed_removals(const HashList* msg);
  static const ::mozilla::safebrowsing::v5::Duration& minimum_wait_duration(const HashList* msg);
  static const ::mozilla::safebrowsing::v5::HashListMetadata& metadata(const HashList* msg);
};

const ::mozilla::safebrowsing::v5::RiceDeltaEncoded32Bit&
HashList::_Internal::additions_four_bytes(const HashList* msg) {
  return *msg->_impl_.compressed_additions_.additions_four_bytes_;
}
const ::mozilla::safebrowsing::v5::RiceDeltaEncoded64Bit&
HashList::_Internal::additions_eight_bytes(const HashList* msg) {
  return *msg->_impl_.compressed_additions_.additions_eight_bytes_;
}
const ::mozilla::safebrowsing::v5::RiceDeltaEncoded128Bit&
HashList::_Internal::additions_sixteen_bytes(const HashList* msg) {
  return *msg->_impl_.compressed_additions_.additions_sixteen_bytes_;
}
const ::mozilla::safebrowsing::v5::RiceDeltaEncoded256Bit&
HashList::_Internal::additions_thirty_two_bytes(const HashList* msg) {
  return *msg->_impl_.compressed_additions_.additions_thirty_two_bytes_;
}
const ::mozilla::safebrowsing::v5::RiceDeltaEncoded32Bit&
HashList::_Internal::compressed_removals(const HashList* msg) {
  return *msg->_impl_.compressed_removals_;
}
const ::mozilla::safebrowsing::v5::Duration&
HashList::_Internal::minimum_wait_duration(const HashList* msg) {
  return *msg->_impl_.minimum_wait_duration_;
}
const ::mozilla::safebrowsing::v5::HashListMetadata&
HashList::_Internal::metadata(const HashList* msg) {
  return *msg->_impl_.metadata_;
}
void HashList::set_allocated_additions_four_bytes(::mozilla::safebrowsing::v5::RiceDeltaEncoded32Bit* additions_four_bytes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_compressed_additions();
  if (additions_four_bytes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(additions_four_bytes);
    if (message_arena != submessage_arena) {
      additions_four_bytes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, additions_four_bytes, submessage_arena);
    }
    set_has_additions_four_bytes();
    _impl_.compressed_additions_.additions_four_bytes_ = additions_four_bytes;
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.v5.HashList.additions_four_bytes)
}
void HashList::set_allocated_additions_eight_bytes(::mozilla::safebrowsing::v5::RiceDeltaEncoded64Bit* additions_eight_bytes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_compressed_additions();
  if (additions_eight_bytes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(additions_eight_bytes);
    if (message_arena != submessage_arena) {
      additions_eight_bytes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, additions_eight_bytes, submessage_arena);
    }
    set_has_additions_eight_bytes();
    _impl_.compressed_additions_.additions_eight_bytes_ = additions_eight_bytes;
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.v5.HashList.additions_eight_bytes)
}
void HashList::set_allocated_additions_sixteen_bytes(::mozilla::safebrowsing::v5::RiceDeltaEncoded128Bit* additions_sixteen_bytes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_compressed_additions();
  if (additions_sixteen_bytes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(additions_sixteen_bytes);
    if (message_arena != submessage_arena) {
      additions_sixteen_bytes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, additions_sixteen_bytes, submessage_arena);
    }
    set_has_additions_sixteen_bytes();
    _impl_.compressed_additions_.additions_sixteen_bytes_ = additions_sixteen_bytes;
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.v5.HashList.additions_sixteen_bytes)
}
void HashList::set_allocated_additions_thirty_two_bytes(::mozilla::safebrowsing::v5::RiceDeltaEncoded256Bit* additions_thirty_two_bytes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_compressed_additions();
  if (additions_thirty_two_bytes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(additions_thirty_two_bytes);
    if (message_arena != submessage_arena) {
      additions_thirty_two_bytes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, additions_thirty_two_bytes, submessage_arena);
    }
    set_has_additions_thirty_two_bytes();
    _impl_.compressed_additions_.additions_thirty_two_bytes_ = additions_thirty_two_bytes;
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.v5.HashList.additions_thirty_two_bytes)
}
HashList::HashList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.v5.HashList)
}
HashList::HashList(const HashList& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  HashList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.sha256_checksum_){}
    , decltype(_impl_.compressed_removals_){nullptr}
    , decltype(_impl_.minimum_wait_duration_){nullptr}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.partial_update_){}
    , decltype(_impl_.compressed_additions_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_version().empty()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sha256_checksum_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha256_checksum_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sha256_checksum().empty()) {
    _this->_impl_.sha256_checksum_.Set(from._internal_sha256_checksum(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_compressed_removals()) {
    _this->_impl_.compressed_removals_ = new ::mozilla::safebrowsing::v5::RiceDeltaEncoded32Bit(*from._impl_.compressed_removals_);
  }
  if (from._internal_has_minimum_wait_duration()) {
    _this->_impl_.minimum_wait_duration_ = new ::mozilla::safebrowsing::v5::Duration(*from._impl_.minimum_wait_duration_);
  }
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::mozilla::safebrowsing::v5::HashListMetadata(*from._impl_.metadata_);
  }
  _this->_impl_.partial_update_ = from._impl_.partial_update_;
  clear_has_compressed_additions();
  switch (from.compressed_additions_case()) {
    case kAdditionsFourBytes: {
      _this->_internal_mutable_additions_four_bytes()->::mozilla::safebrowsing::v5::RiceDeltaEncoded32Bit::MergeFrom(
          from._internal_additions_four_bytes());
      break;
    }
    case kAdditionsEightBytes: {
      _this->_internal_mutable_additions_eight_bytes()->::mozilla::safebrowsing::v5::RiceDeltaEncoded64Bit::MergeFrom(
          from._internal_additions_eight_bytes());
      break;
    }
    case kAdditionsSixteenBytes: {
      _this->_internal_mutable_additions_sixteen_bytes()->::mozilla::safebrowsing::v5::RiceDeltaEncoded128Bit::MergeFrom(
          from._internal_additions_sixteen_bytes());
      break;
    }
    case kAdditionsThirtyTwoBytes: {
      _this->_internal_mutable_additions_thirty_two_bytes()->::mozilla::safebrowsing::v5::RiceDeltaEncoded256Bit::MergeFrom(
          from._internal_additions_thirty_two_bytes());
      break;
    }
    case COMPRESSED_ADDITIONS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.v5.HashList)
}

inline void HashList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.sha256_checksum_){}
    , decltype(_impl_.compressed_removals_){nullptr}
    , decltype(_impl_.minimum_wait_duration_){nullptr}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.partial_update_){false}
    , decltype(_impl_.compressed_additions_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sha256_checksum_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha256_checksum_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_compressed_additions();
}

HashList::~HashList() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.v5.HashList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HashList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.version_.Destroy();
  _impl_.sha256_checksum_.Destroy();
  if (this != internal_default_instance()) delete _impl_.compressed_removals_;
  if (this != internal_default_instance()) delete _impl_.minimum_wait_duration_;
  if (this != internal_default_instance()) delete _impl_.metadata_;
  if (has_compressed_additions()) {
    clear_compressed_additions();
  }
}

void HashList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HashList::clear_compressed_additions() {
// @@protoc_insertion_point(one_of_clear_start:mozilla.safebrowsing.v5.HashList)
  switch (compressed_additions_case()) {
    case kAdditionsFourBytes: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.compressed_additions_.additions_four_bytes_;
      }
      break;
    }
    case kAdditionsEightBytes: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.compressed_additions_.additions_eight_bytes_;
      }
      break;
    }
    case kAdditionsSixteenBytes: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.compressed_additions_.additions_sixteen_bytes_;
      }
      break;
    }
    case kAdditionsThirtyTwoBytes: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.compressed_additions_.additions_thirty_two_bytes_;
      }
      break;
    }
    case COMPRESSED_ADDITIONS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = COMPRESSED_ADDITIONS_NOT_SET;
}


void HashList::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.v5.HashList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.version_.ClearToEmpty();
  _impl_.sha256_checksum_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.compressed_removals_ != nullptr) {
    delete _impl_.compressed_removals_;
  }
  _impl_.compressed_removals_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.minimum_wait_duration_ != nullptr) {
    delete _impl_.minimum_wait_duration_;
  }
  _impl_.minimum_wait_duration_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
  _impl_.partial_update_ = false;
  clear_compressed_additions();
  _internal_metadata_.Clear<std::string>();
}

const char* HashList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // bytes version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool partial_update = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.partial_update_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .mozilla.safebrowsing.v5.RiceDeltaEncoded32Bit additions_four_bytes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_additions_four_bytes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .mozilla.safebrowsing.v5.RiceDeltaEncoded32Bit compressed_removals = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_compressed_removals(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .mozilla.safebrowsing.v5.Duration minimum_wait_duration = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_minimum_wait_duration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes sha256_checksum = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_sha256_checksum();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .mozilla.safebrowsing.v5.HashListMetadata metadata = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .mozilla.safebrowsing.v5.RiceDeltaEncoded64Bit additions_eight_bytes = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_additions_eight_bytes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .mozilla.safebrowsing.v5.RiceDeltaEncoded128Bit additions_sixteen_bytes = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_additions_sixteen_bytes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .mozilla.safebrowsing.v5.RiceDeltaEncoded256Bit additions_thirty_two_bytes = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_additions_thirty_two_bytes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HashList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.v5.HashList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "mozilla.safebrowsing.v5.HashList.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bytes version = 2;
  if (!this->_internal_version().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_version(), target);
  }

  // bool partial_update = 3;
  if (this->_internal_partial_update() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_partial_update(), target);
  }

  // .mozilla.safebrowsing.v5.RiceDeltaEncoded32Bit additions_four_bytes = 4;
  if (_internal_has_additions_four_bytes()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::additions_four_bytes(this),
        _Internal::additions_four_bytes(this).GetCachedSize(), target, stream);
  }

  // .mozilla.safebrowsing.v5.RiceDeltaEncoded32Bit compressed_removals = 5;
  if (this->_internal_has_compressed_removals()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::compressed_removals(this),
        _Internal::compressed_removals(this).GetCachedSize(), target, stream);
  }

  // .mozilla.safebrowsing.v5.Duration minimum_wait_duration = 6;
  if (this->_internal_has_minimum_wait_duration()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::minimum_wait_duration(this),
        _Internal::minimum_wait_duration(this).GetCachedSize(), target, stream);
  }

  // bytes sha256_checksum = 7;
  if (!this->_internal_sha256_checksum().empty()) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_sha256_checksum(), target);
  }

  // .mozilla.safebrowsing.v5.HashListMetadata metadata = 8;
  if (this->_internal_has_metadata()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // .mozilla.safebrowsing.v5.RiceDeltaEncoded64Bit additions_eight_bytes = 9;
  if (_internal_has_additions_eight_bytes()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::additions_eight_bytes(this),
        _Internal::additions_eight_bytes(this).GetCachedSize(), target, stream);
  }

  // .mozilla.safebrowsing.v5.RiceDeltaEncoded128Bit additions_sixteen_bytes = 10;
  if (_internal_has_additions_sixteen_bytes()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::additions_sixteen_bytes(this),
        _Internal::additions_sixteen_bytes(this).GetCachedSize(), target, stream);
  }

  // .mozilla.safebrowsing.v5.RiceDeltaEncoded256Bit additions_thirty_two_bytes = 11;
  if (_internal_has_additions_thirty_two_bytes()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::additions_thirty_two_bytes(this),
        _Internal::additions_thirty_two_bytes(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.v5.HashList)
  return target;
}

size_t HashList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.v5.HashList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bytes version = 2;
  if (!this->_internal_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_version());
  }

  // bytes sha256_checksum = 7;
  if (!this->_internal_sha256_checksum().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sha256_checksum());
  }

  // .mozilla.safebrowsing.v5.RiceDeltaEncoded32Bit compressed_removals = 5;
  if (this->_internal_has_compressed_removals()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.compressed_removals_);
  }

  // .mozilla.safebrowsing.v5.Duration minimum_wait_duration = 6;
  if (this->_internal_has_minimum_wait_duration()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.minimum_wait_duration_);
  }

  // .mozilla.safebrowsing.v5.HashListMetadata metadata = 8;
  if (this->_internal_has_metadata()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  // bool partial_update = 3;
  if (this->_internal_partial_update() != 0) {
    total_size += 1 + 1;
  }

  switch (compressed_additions_case()) {
    // .mozilla.safebrowsing.v5.RiceDeltaEncoded32Bit additions_four_bytes = 4;
    case kAdditionsFourBytes: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.compressed_additions_.additions_four_bytes_);
      break;
    }
    // .mozilla.safebrowsing.v5.RiceDeltaEncoded64Bit additions_eight_bytes = 9;
    case kAdditionsEightBytes: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.compressed_additions_.additions_eight_bytes_);
      break;
    }
    // .mozilla.safebrowsing.v5.RiceDeltaEncoded128Bit additions_sixteen_bytes = 10;
    case kAdditionsSixteenBytes: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.compressed_additions_.additions_sixteen_bytes_);
      break;
    }
    // .mozilla.safebrowsing.v5.RiceDeltaEncoded256Bit additions_thirty_two_bytes = 11;
    case kAdditionsThirtyTwoBytes: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.compressed_additions_.additions_thirty_two_bytes_);
      break;
    }
    case COMPRESSED_ADDITIONS_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HashList::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const HashList*>(
      &from));
}

void HashList::MergeFrom(const HashList& from) {
  HashList* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.v5.HashList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_version().empty()) {
    _this->_internal_set_version(from._internal_version());
  }
  if (!from._internal_sha256_checksum().empty()) {
    _this->_internal_set_sha256_checksum(from._internal_sha256_checksum());
  }
  if (from._internal_has_compressed_removals()) {
    _this->_internal_mutable_compressed_removals()->::mozilla::safebrowsing::v5::RiceDeltaEncoded32Bit::MergeFrom(
        from._internal_compressed_removals());
  }
  if (from._internal_has_minimum_wait_duration()) {
    _this->_internal_mutable_minimum_wait_duration()->::mozilla::safebrowsing::v5::Duration::MergeFrom(
        from._internal_minimum_wait_duration());
  }
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::mozilla::safebrowsing::v5::HashListMetadata::MergeFrom(
        from._internal_metadata());
  }
  if (from._internal_partial_update() != 0) {
    _this->_internal_set_partial_update(from._internal_partial_update());
  }
  switch (from.compressed_additions_case()) {
    case kAdditionsFourBytes: {
      _this->_internal_mutable_additions_four_bytes()->::mozilla::safebrowsing::v5::RiceDeltaEncoded32Bit::MergeFrom(
          from._internal_additions_four_bytes());
      break;
    }
    case kAdditionsEightBytes: {
      _this->_internal_mutable_additions_eight_bytes()->::mozilla::safebrowsing::v5::RiceDeltaEncoded64Bit::MergeFrom(
          from._internal_additions_eight_bytes());
      break;
    }
    case kAdditionsSixteenBytes: {
      _this->_internal_mutable_additions_sixteen_bytes()->::mozilla::safebrowsing::v5::RiceDeltaEncoded128Bit::MergeFrom(
          from._internal_additions_sixteen_bytes());
      break;
    }
    case kAdditionsThirtyTwoBytes: {
      _this->_internal_mutable_additions_thirty_two_bytes()->::mozilla::safebrowsing::v5::RiceDeltaEncoded256Bit::MergeFrom(
          from._internal_additions_thirty_two_bytes());
      break;
    }
    case COMPRESSED_ADDITIONS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HashList::CopyFrom(const HashList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.v5.HashList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HashList::IsInitialized() const {
  return true;
}

void HashList::InternalSwap(HashList* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sha256_checksum_, lhs_arena,
      &other->_impl_.sha256_checksum_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HashList, _impl_.partial_update_)
      + sizeof(HashList::_impl_.partial_update_)
      - PROTOBUF_FIELD_OFFSET(HashList, _impl_.compressed_removals_)>(
          reinterpret_cast<char*>(&_impl_.compressed_removals_),
          reinterpret_cast<char*>(&other->_impl_.compressed_removals_));
  swap(_impl_.compressed_additions_, other->_impl_.compressed_additions_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string HashList::GetTypeName() const {
  return "mozilla.safebrowsing.v5.HashList";
}


// ===================================================================

class BatchGetHashListsRequest::_Internal {
 public:
  static const ::mozilla::safebrowsing::v5::SizeConstraints& size_constraints(const BatchGetHashListsRequest* msg);
};

const ::mozilla::safebrowsing::v5::SizeConstraints&
BatchGetHashListsRequest::_Internal::size_constraints(const BatchGetHashListsRequest* msg) {
  return *msg->_impl_.size_constraints_;
}
BatchGetHashListsRequest::BatchGetHashListsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.v5.BatchGetHashListsRequest)
}
BatchGetHashListsRequest::BatchGetHashListsRequest(const BatchGetHashListsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BatchGetHashListsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.names_){from._impl_.names_}
    , decltype(_impl_.version_){from._impl_.version_}
    , decltype(_impl_.size_constraints_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_size_constraints()) {
    _this->_impl_.size_constraints_ = new ::mozilla::safebrowsing::v5::SizeConstraints(*from._impl_.size_constraints_);
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.v5.BatchGetHashListsRequest)
}

inline void BatchGetHashListsRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.names_){arena}
    , decltype(_impl_.version_){arena}
    , decltype(_impl_.size_constraints_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchGetHashListsRequest::~BatchGetHashListsRequest() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.v5.BatchGetHashListsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchGetHashListsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.names_.~RepeatedPtrField();
  _impl_.version_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.size_constraints_;
}

void BatchGetHashListsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchGetHashListsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.v5.BatchGetHashListsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.names_.Clear();
  _impl_.version_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.size_constraints_ != nullptr) {
    delete _impl_.size_constraints_;
  }
  _impl_.size_constraints_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* BatchGetHashListsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string names = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_names();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, nullptr));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_version();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .mozilla.safebrowsing.v5.SizeConstraints size_constraints = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_size_constraints(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchGetHashListsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.v5.BatchGetHashListsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string names = 1;
  for (int i = 0, n = this->_internal_names_size(); i < n; i++) {
    const auto& s = this->_internal_names(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "mozilla.safebrowsing.v5.BatchGetHashListsRequest.names");
    target = stream->WriteString(1, s, target);
  }

  // repeated bytes version = 2;
  for (int i = 0, n = this->_internal_version_size(); i < n; i++) {
    const auto& s = this->_internal_version(i);
    target = stream->WriteBytes(2, s, target);
  }

  // .mozilla.safebrowsing.v5.SizeConstraints size_constraints = 4;
  if (this->_internal_has_size_constraints()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::size_constraints(this),
        _Internal::size_constraints(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.v5.BatchGetHashListsRequest)
  return target;
}

size_t BatchGetHashListsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.v5.BatchGetHashListsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string names = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.names_.size());
  for (int i = 0, n = _impl_.names_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.names_.Get(i));
  }

  // repeated bytes version = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.version_.size());
  for (int i = 0, n = _impl_.version_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.version_.Get(i));
  }

  // .mozilla.safebrowsing.v5.SizeConstraints size_constraints = 4;
  if (this->_internal_has_size_constraints()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.size_constraints_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BatchGetHashListsRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BatchGetHashListsRequest*>(
      &from));
}

void BatchGetHashListsRequest::MergeFrom(const BatchGetHashListsRequest& from) {
  BatchGetHashListsRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.v5.BatchGetHashListsRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.names_.MergeFrom(from._impl_.names_);
  _this->_impl_.version_.MergeFrom(from._impl_.version_);
  if (from._internal_has_size_constraints()) {
    _this->_internal_mutable_size_constraints()->::mozilla::safebrowsing::v5::SizeConstraints::MergeFrom(
        from._internal_size_constraints());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BatchGetHashListsRequest::CopyFrom(const BatchGetHashListsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.v5.BatchGetHashListsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchGetHashListsRequest::IsInitialized() const {
  return true;
}

void BatchGetHashListsRequest::InternalSwap(BatchGetHashListsRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.names_.InternalSwap(&other->_impl_.names_);
  _impl_.version_.InternalSwap(&other->_impl_.version_);
  swap(_impl_.size_constraints_, other->_impl_.size_constraints_);
}

std::string BatchGetHashListsRequest::GetTypeName() const {
  return "mozilla.safebrowsing.v5.BatchGetHashListsRequest";
}


// ===================================================================

class BatchGetHashListsResponse::_Internal {
 public:
};

BatchGetHashListsResponse::BatchGetHashListsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.v5.BatchGetHashListsResponse)
}
BatchGetHashListsResponse::BatchGetHashListsResponse(const BatchGetHashListsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BatchGetHashListsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hash_lists_){from._impl_.hash_lists_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.v5.BatchGetHashListsResponse)
}

inline void BatchGetHashListsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hash_lists_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchGetHashListsResponse::~BatchGetHashListsResponse() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.v5.BatchGetHashListsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchGetHashListsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hash_lists_.~RepeatedPtrField();
}

void BatchGetHashListsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchGetHashListsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.v5.BatchGetHashListsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hash_lists_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BatchGetHashListsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .mozilla.safebrowsing.v5.HashList hash_lists = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_hash_lists(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchGetHashListsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.v5.BatchGetHashListsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.v5.HashList hash_lists = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hash_lists_size()); i < n; i++) {
    const auto& repfield = this->_internal_hash_lists(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.v5.BatchGetHashListsResponse)
  return target;
}

size_t BatchGetHashListsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.v5.BatchGetHashListsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.v5.HashList hash_lists = 1;
  total_size += 1UL * this->_internal_hash_lists_size();
  for (const auto& msg : this->_impl_.hash_lists_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BatchGetHashListsResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BatchGetHashListsResponse*>(
      &from));
}

void BatchGetHashListsResponse::MergeFrom(const BatchGetHashListsResponse& from) {
  BatchGetHashListsResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.v5.BatchGetHashListsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.hash_lists_.MergeFrom(from._impl_.hash_lists_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BatchGetHashListsResponse::CopyFrom(const BatchGetHashListsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.v5.BatchGetHashListsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchGetHashListsResponse::IsInitialized() const {
  return true;
}

void BatchGetHashListsResponse::InternalSwap(BatchGetHashListsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.hash_lists_.InternalSwap(&other->_impl_.hash_lists_);
}

std::string BatchGetHashListsResponse::GetTypeName() const {
  return "mozilla.safebrowsing.v5.BatchGetHashListsResponse";
}


// ===================================================================

class ListHashListsRequest::_Internal {
 public:
};

ListHashListsRequest::ListHashListsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.v5.ListHashListsRequest)
}
ListHashListsRequest::ListHashListsRequest(const ListHashListsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ListHashListsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_page_token().empty()) {
    _this->_impl_.page_token_.Set(from._internal_page_token(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.page_size_ = from._impl_.page_size_;
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.v5.ListHashListsRequest)
}

inline void ListHashListsRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListHashListsRequest::~ListHashListsRequest() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.v5.ListHashListsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListHashListsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.page_token_.Destroy();
}

void ListHashListsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListHashListsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.v5.ListHashListsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.page_token_.ClearToEmpty();
  _impl_.page_size_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* ListHashListsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 page_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.page_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListHashListsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.v5.ListHashListsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 page_size = 1;
  if (this->_internal_page_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_page_size(), target);
  }

  // string page_token = 2;
  if (!this->_internal_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_page_token().data(), static_cast<int>(this->_internal_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "mozilla.safebrowsing.v5.ListHashListsRequest.page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.v5.ListHashListsRequest)
  return target;
}

size_t ListHashListsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.v5.ListHashListsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string page_token = 2;
  if (!this->_internal_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_token());
  }

  // int32 page_size = 1;
  if (this->_internal_page_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_page_size());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ListHashListsRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ListHashListsRequest*>(
      &from));
}

void ListHashListsRequest::MergeFrom(const ListHashListsRequest& from) {
  ListHashListsRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.v5.ListHashListsRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_page_token().empty()) {
    _this->_internal_set_page_token(from._internal_page_token());
  }
  if (from._internal_page_size() != 0) {
    _this->_internal_set_page_size(from._internal_page_size());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ListHashListsRequest::CopyFrom(const ListHashListsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.v5.ListHashListsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListHashListsRequest::IsInitialized() const {
  return true;
}

void ListHashListsRequest::InternalSwap(ListHashListsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.page_token_, lhs_arena,
      &other->_impl_.page_token_, rhs_arena
  );
  swap(_impl_.page_size_, other->_impl_.page_size_);
}

std::string ListHashListsRequest::GetTypeName() const {
  return "mozilla.safebrowsing.v5.ListHashListsRequest";
}


// ===================================================================

class ListHashListsResponse::_Internal {
 public:
};

ListHashListsResponse::ListHashListsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.v5.ListHashListsResponse)
}
ListHashListsResponse::ListHashListsResponse(const ListHashListsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ListHashListsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hash_lists_){from._impl_.hash_lists_}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_next_page_token().empty()) {
    _this->_impl_.next_page_token_.Set(from._internal_next_page_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.v5.ListHashListsResponse)
}

inline void ListHashListsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hash_lists_){arena}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListHashListsResponse::~ListHashListsResponse() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.v5.ListHashListsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListHashListsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hash_lists_.~RepeatedPtrField();
  _impl_.next_page_token_.Destroy();
}

void ListHashListsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListHashListsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.v5.ListHashListsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hash_lists_.Clear();
  _impl_.next_page_token_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* ListHashListsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .mozilla.safebrowsing.v5.HashList hash_lists = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_hash_lists(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string next_page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_next_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListHashListsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.v5.ListHashListsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.v5.HashList hash_lists = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hash_lists_size()); i < n; i++) {
    const auto& repfield = this->_internal_hash_lists(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_page_token().data(), static_cast<int>(this->_internal_next_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "mozilla.safebrowsing.v5.ListHashListsResponse.next_page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_next_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.v5.ListHashListsResponse)
  return target;
}

size_t ListHashListsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.v5.ListHashListsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.v5.HashList hash_lists = 1;
  total_size += 1UL * this->_internal_hash_lists_size();
  for (const auto& msg : this->_impl_.hash_lists_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_next_page_token());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ListHashListsResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ListHashListsResponse*>(
      &from));
}

void ListHashListsResponse::MergeFrom(const ListHashListsResponse& from) {
  ListHashListsResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.v5.ListHashListsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.hash_lists_.MergeFrom(from._impl_.hash_lists_);
  if (!from._internal_next_page_token().empty()) {
    _this->_internal_set_next_page_token(from._internal_next_page_token());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ListHashListsResponse::CopyFrom(const ListHashListsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.v5.ListHashListsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListHashListsResponse::IsInitialized() const {
  return true;
}

void ListHashListsResponse::InternalSwap(ListHashListsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.hash_lists_.InternalSwap(&other->_impl_.hash_lists_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.next_page_token_, lhs_arena,
      &other->_impl_.next_page_token_, rhs_arena
  );
}

std::string ListHashListsResponse::GetTypeName() const {
  return "mozilla.safebrowsing.v5.ListHashListsResponse";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace v5
}  // namespace safebrowsing
}  // namespace mozilla
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::v5::SearchHashesRequest*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::v5::SearchHashesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::v5::SearchHashesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::v5::Duration*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::v5::Duration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::v5::Duration >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::v5::SearchHashesResponse*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::v5::SearchHashesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::v5::SearchHashesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::v5::FullHash_FullHashDetail*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::v5::FullHash_FullHashDetail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::v5::FullHash_FullHashDetail >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::v5::FullHash*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::v5::FullHash >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::v5::FullHash >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::v5::GetHashListRequest*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::v5::GetHashListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::v5::GetHashListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::v5::SizeConstraints*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::v5::SizeConstraints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::v5::SizeConstraints >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::v5::RiceDeltaEncoded32Bit*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::v5::RiceDeltaEncoded32Bit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::v5::RiceDeltaEncoded32Bit >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::v5::RiceDeltaEncoded64Bit*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::v5::RiceDeltaEncoded64Bit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::v5::RiceDeltaEncoded64Bit >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::v5::RiceDeltaEncoded128Bit*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::v5::RiceDeltaEncoded128Bit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::v5::RiceDeltaEncoded128Bit >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::v5::RiceDeltaEncoded256Bit*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::v5::RiceDeltaEncoded256Bit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::v5::RiceDeltaEncoded256Bit >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::v5::HashListMetadata*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::v5::HashListMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::v5::HashListMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::v5::HashList*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::v5::HashList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::v5::HashList >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::v5::BatchGetHashListsRequest*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::v5::BatchGetHashListsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::v5::BatchGetHashListsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::v5::BatchGetHashListsResponse*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::v5::BatchGetHashListsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::v5::BatchGetHashListsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::v5::ListHashListsRequest*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::v5::ListHashListsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::v5::ListHashListsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::v5::ListHashListsResponse*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::v5::ListHashListsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::v5::ListHashListsResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
