diff --git a/hwy/aligned_allocator.h b/hwy/aligned_allocator.h
--- a/hwy/aligned_allocator.h
+++ b/hwy/aligned_allocator.h
@@ -32,6 +32,8 @@
 #include "hwy/base.h"
 #include "hwy/per_target.h"
 
+#include <mozilla/Attributes.h>
+
 namespace hwy {
 
 // Minimum alignment of allocated memory for use in HWY_ASSUME_ALIGNED, which
@@ -272,8 +274,8 @@ class Span {
   Span() = default;
   Span(T* data, size_t size) : size_(size), data_(data) {}
   template <typename U>
-  Span(U u) : Span(u.data(), u.size()) {}
-  Span(std::initializer_list<const T> v) : Span(v.begin(), v.size()) {}
+  MOZ_IMPLICIT Span(U u) : Span(u.data(), u.size()) {}
+  MOZ_IMPLICIT Span(std::initializer_list<const T> v) : Span(v.begin(), v.size()) {}
 
   // Copies the contents of the initializer list to the span.
   Span<T>& operator=(std::initializer_list<const T> v) {
diff --git a/hwy/base.h b/hwy/base.h
--- a/hwy/base.h
+++ b/hwy/base.h
@@ -33,6 +33,8 @@
 #include "hwy/detect_compiler_arch.h"
 #include "hwy/highway_export.h"
 
+#include <mozilla/Attributes.h>
+
 // API version (https://semver.org/); keep in sync with CMakeLists.txt.
 #define HWY_MAJOR 1
 #define HWY_MINOR 3
@@ -1283,7 +1285,7 @@ struct alignas(2) float16_t {
 #if HWY_HAVE_SCALAR_F16_TYPE
   // NEON vget/set_lane intrinsics and SVE `svaddv` could use explicit
   // float16_t(intrinsic()), but user code expects implicit conversions.
-  constexpr float16_t(Native arg) noexcept : native(arg) {}
+  MOZ_IMPLICIT constexpr float16_t(Native arg) noexcept : native(arg) {}
   constexpr operator Native() const noexcept { return native; }
 #endif
 
@@ -1310,7 +1312,7 @@ struct alignas(2) float16_t {
 #if HWY_HAVE_SCALAR_F16_OPERATORS || HWY_IDE
   template <typename T, hwy::EnableIf<!IsSame<RemoveCvRef<T>, float16_t>() &&
                                       IsConvertible<T, Native>()>* = nullptr>
-  constexpr float16_t(T&& arg) noexcept
+  MOZ_IMPLICIT constexpr float16_t(T&& arg) noexcept
       : native(static_cast<Native>(static_cast<T&&>(arg))) {}
 
   template <typename T, hwy::EnableIf<!IsSame<RemoveCvRef<T>, float16_t>() &&
@@ -1769,7 +1771,7 @@ struct alignas(2) bfloat16_t {
 
 // Only enable implicit conversions if we have a native type.
 #if HWY_HAVE_SCALAR_BF16_TYPE || HWY_IDE
-  constexpr bfloat16_t(Native arg) noexcept : native(arg) {}
+  MOZ_IMPLICIT constexpr bfloat16_t(Native arg) noexcept : native(arg) {}
   constexpr operator Native() const noexcept { return native; }
 #endif
 
